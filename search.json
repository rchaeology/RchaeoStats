[
  {
    "objectID": "slides/content/00_welcome.html#r",
    "href": "slides/content/00_welcome.html#r",
    "title": "Hello üëã",
    "section": "R",
    "text": "R\nPronounced /‚ÄôArrrgh/\n\nGIPHY",
    "crumbs": [
      "Slides",
      "00 - Welcome"
    ]
  },
  {
    "objectID": "slides/content/00_welcome.html#why-r",
    "href": "slides/content/00_welcome.html#why-r",
    "title": "Hello üëã",
    "section": "Why R?",
    "text": "Why R?\nBecause it‚Äôs the best!\nEnd of presentation.\n\nArtwork by @allison_horst.",
    "crumbs": [
      "Slides",
      "00 - Welcome"
    ]
  },
  {
    "objectID": "slides/content/00_welcome.html#why-r-1",
    "href": "slides/content/00_welcome.html#why-r-1",
    "title": "Hello üëã",
    "section": "Why R?",
    "text": "Why R?\nR is a free and open source software environment for statistical computing and graphics\nThere are 20000+ available packages on CRAN\nThe R community is pretty cool\n\nArtwork by @allison_horst.",
    "crumbs": [
      "Slides",
      "00 - Welcome"
    ]
  },
  {
    "objectID": "slides/content/00_welcome.html#why-rchaeology",
    "href": "slides/content/00_welcome.html#why-rchaeology",
    "title": "Hello üëã",
    "section": "Why R(chaeology)?",
    "text": "Why R(chaeology)?\nSeems to be the most popular\nBatist & Roe (2024). DOI: 10.11141/ia.67.13",
    "crumbs": [
      "Slides",
      "00 - Welcome"
    ]
  },
  {
    "objectID": "slides/content/00_welcome.html#why-rstudio",
    "href": "slides/content/00_welcome.html#why-rstudio",
    "title": "Hello üëã",
    "section": "Why RStudio?",
    "text": "Why RStudio?\nRStudio is an integrated development environment (IDE) specifically for R\nIt provides a bunch of extra features to make using R a delight!",
    "crumbs": [
      "Slides",
      "00 - Welcome"
    ]
  },
  {
    "objectID": "slides/content/00_welcome.html#tidyverse",
    "href": "slides/content/00_welcome.html#tidyverse",
    "title": "Hello üëã",
    "section": "tidyverse",
    "text": "tidyverse\nThe tidyverse is a collection of R packages sharing the same data science philosophy\nIt provides a nice workflow for cleaning, visualising, and transforming data\nAspects of ‚Äòbase R‚Äô will also be covered",
    "crumbs": [
      "Slides",
      "00 - Welcome"
    ]
  },
  {
    "objectID": "slides/content/00_welcome.html#about-the-materials",
    "href": "slides/content/00_welcome.html#about-the-materials",
    "title": "Hello üëã",
    "section": "About the materials",
    "text": "About the materials\nIt is not enough to cover all important topics.\nIt is enough to teach you how to find answers and implement them yourself.",
    "crumbs": [
      "Slides",
      "00 - Welcome"
    ]
  },
  {
    "objectID": "slides/content/00_welcome.html#the-datasets-sheep-astragali",
    "href": "slides/content/00_welcome.html#the-datasets-sheep-astragali",
    "title": "Hello üëã",
    "section": "The datasets: Sheep Astragali",
    "text": "The datasets: Sheep Astragali\nSheep astragulus morphology from Iron Age Eastern Mediterranean.\nnmar79. (2023). nmar79/Med_Sheep_Astragals: v0.1 (v0.1). Zenodo. https://doi.org/10.5281/zenodo.10276147",
    "crumbs": [
      "Slides",
      "00 - Welcome"
    ]
  },
  {
    "objectID": "slides/content/00_welcome.html#the-datasets-sheep-astragali-1",
    "href": "slides/content/00_welcome.html#the-datasets-sheep-astragali-1",
    "title": "Hello üëã",
    "section": "The datasets: Sheep Astragali",
    "text": "The datasets: Sheep Astragali\n\n\n\n\n\n\n\ncolumn\ndescription\n\n\n\n\nspecID\nSpecimen ID\n\n\nTaxon\nTaxon\n\n\nSite\nSite code: DOR = Dor; KSN = Keisan; ABM = ABM (see group)\n\n\nZone\nZone: Coastal, inland, or Cyprus\n\n\nPeriod\nTime period: IA2 = Iron age; PER = Persian\n\n\ngroup\nDor = southern Levant sample Iron Age 2 Tel Dor; Keisan = southern Levant sample Iron Age 2 and Persian Tell Keisan; southern Levant sample ABM = Iron Age 2 Abel Beth Maacah; LTD = Cypriot sample from Archaic-Classical Lingrin tou Digeni\n\n\nGLl\nGreatest length lateral astragalus measurement\n\n\nBd\nGreatest breadth of distal end astragalus measurement\n\n\nDl\nGreatest depth lateral astragalus measurement",
    "crumbs": [
      "Slides",
      "00 - Welcome"
    ]
  },
  {
    "objectID": "slides/content/00_welcome.html#the-datasets-kiwulan-burials",
    "href": "slides/content/00_welcome.html#the-datasets-kiwulan-burials",
    "title": "Hello üëã",
    "section": "The datasets: Kiwulan Burials",
    "text": "The datasets: Kiwulan Burials\nBurial data from northeastern Taiwan ranging from the Iron Age through the European colonization period.\n\nLi-Ying Wang & Ben Marwick, (2021). Compendium of R code and data for ‚ÄúA Bayesian networks approach to infer social changes from burials in northeastern Taiwan during the European colonization period‚Äù. Accessed 23 Aug 2021. Online at https://osf.io/xga6n/",
    "crumbs": [
      "Slides",
      "00 - Welcome"
    ]
  },
  {
    "objectID": "slides/content/00_welcome.html#the-datasets-kiwulan-burials-1",
    "href": "slides/content/00_welcome.html#the-datasets-kiwulan-burials-1",
    "title": "Hello üëã",
    "section": "The datasets: Kiwulan Burials",
    "text": "The datasets: Kiwulan Burials\n\n\n\n\n\n\n\nVariable\nDescription\n\n\n\n\nLayer\nLayer of the grave. 1 = Upper culture layer; 2 = Lower culture layer.\n\n\nID\nUnique identifier of burials\n\n\nBurial_axis\nNot sure. Not relevant\n\n\nDegree_axis\nNot sure. Not relevant\n\n\nCondition\nCondition of the burial. 1 = complete; 2 = partial disturbed; 3 = severe disturbed; 4 = unidentified.\n\n\nGender\nBiological sex of the skeletal remains. 1 = Male; 2 = Probable Male; 3 = Female; 4 = Probable Female.\n\n\nAge\nAge-at-death of the skeletal remains. 1 = infant (0-2 years); 2 = child (3-12 years); 3 = teenager (12-20 years); 4 = young adult(20-35 years); 5 = middle adult (35-50 years); 6 = old adult (50+); 7 = adult (20+); 8 = approximate adult\n\n\nLength\nLength of burial\n\n\nWidth\nWidth of burial\n\n\nHeight\nHeight of burial",
    "crumbs": [
      "Slides",
      "00 - Welcome"
    ]
  },
  {
    "objectID": "slides/content/01_rstudio-project.html#rstudio-project",
    "href": "slides/content/01_rstudio-project.html#rstudio-project",
    "title": "RStudio Projects",
    "section": "RStudio Project",
    "text": "RStudio Project\nWell begun is half done\n\nGIPHY",
    "crumbs": [
      "Slides",
      "01 - RStudio Projects"
    ]
  },
  {
    "objectID": "slides/content/01_rstudio-project.html#rstudio-project-1",
    "href": "slides/content/01_rstudio-project.html#rstudio-project-1",
    "title": "RStudio Projects",
    "section": "RStudio Project",
    "text": "RStudio Project\nThe best way to organise a project is using an RStudio Project.\nAn RStudio Project creates a self-contained, portable project.\nIt makes working with file paths easier\nNo more absolute file paths using setwd(), that will break on any other computer.\nFile paths only need to be relative to the project root.",
    "crumbs": [
      "Slides",
      "01 - RStudio Projects"
    ]
  },
  {
    "objectID": "slides/content/01_rstudio-project.html#rstudio-project-2",
    "href": "slides/content/01_rstudio-project.html#rstudio-project-2",
    "title": "RStudio Projects",
    "section": "RStudio Project",
    "text": "RStudio Project\n\n\n\n\nArtwork by @allison_horst\n\n\nBECOMES‚Ä¶",
    "crumbs": [
      "Slides",
      "01 - RStudio Projects"
    ]
  },
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "R and Statistics for Archaeologists",
    "section": "",
    "text": "The teaching materials on this site are intended for teaching Statistics and R programming workshops to archaeologists.\nThis course follows the tidyverse philosophy of understanding and analysing your data through a repeated cycle of transforming, visualising, and modelling.\n\n\n\nImage taken from the R4DS book\n\n\nUpcoming and past workshops can be found here:",
    "crumbs": [
      "Course Overview"
    ]
  },
  {
    "objectID": "index.html#course-overview",
    "href": "index.html#course-overview",
    "title": "R and Statistics for Archaeologists",
    "section": "",
    "text": "The teaching materials on this site are intended for teaching Statistics and R programming workshops to archaeologists.\nThis course follows the tidyverse philosophy of understanding and analysing your data through a repeated cycle of transforming, visualising, and modelling.\n\n\n\nImage taken from the R4DS book\n\n\nUpcoming and past workshops can be found here:",
    "crumbs": [
      "Course Overview"
    ]
  },
  {
    "objectID": "index.html#course-modules",
    "href": "index.html#course-modules",
    "title": "R and Statistics for Archaeologists",
    "section": "Course modules",
    "text": "Course modules\nThe course contains multiple modules that can be used to construct workshops of varying durations and customised to suit the participants‚Äô needs.\n\nCore\nThe core module contains an introduction to R and RStudio, an example workflow, and data import and cleaning.\n\n\n\nComponent\nDescription\nMaterials\nDuration\n\n\n\n\nSetup\nInstallation of R and RStudio\n00 - Getting Started\nUnknown\n\n\nR Basics\nBasics of the R programming language\nCode-along: 01 - R Basics\nUnknown\n\n\nExample workflow\n\nCode-along: 02 - An Example Workflow\n~1 hour\n\n\nProject organisation\nA brief discussion of how to organise a project with RStudio Projects.\nCode-along: 03 - Getting Organised  Slides: 01 - RStudio Projects\n~10 mins\n\n\nCleaning Data\nImporting and cleaning data from a .xlsx file.\nCode-along: 04 - Cleaning Data\nUnknown\n\n\nStats basics\nBasics of statistics\nSlides: 02 - Stats Basics\nUnknown\n\n\n\n\n\nUnderstand\n\n\n\nComponent\nDescription\nMaterials\nDuration\n\n\n\n\nVisualising Data\nVisualising the cleaned data with ggplot2\nCode-along: 05 - Visualising Data\nUnknown\n\n\nTransforming Data\nTransforming the cleaned data with dplyr\nCode-along: 06 - Transforming Data\nUnknown\n\n\n\n\n\nCommunicate\n\n\n\nComponent\nDescription\nMaterials\nDuration\n\n\n\n\nCommunicating Results\nCreating a Quarto document to combine narrative and code with output\nCode-along: 08 - Communicating Results\n~90 mins\n\n\n\n\n\nExtensions\nFuture work is planned on the following extensions (help needed!):\n\nCollaborative coding with Git(Hub)\nReproducible Research\nTopic-specific modules\n\nSkeletal age-at-death and sex estimation\nRadiocarbon dating\nDendrochronology\netc.",
    "crumbs": [
      "Course Overview"
    ]
  },
  {
    "objectID": "index.html#course-outcomes",
    "href": "index.html#course-outcomes",
    "title": "R and Statistics for Archaeologists",
    "section": "Course outcomes",
    "text": "Course outcomes\nUnderstand enough to explore more on your own and be able to solve the issues you run into. Because you will run into issues. Everyone runs into issues. It‚Äôs VERY satisfying once you have solved them, though.",
    "crumbs": [
      "Course Overview"
    ]
  },
  {
    "objectID": "docs/02_workflow.html",
    "href": "docs/02_workflow.html",
    "title": "An Example Workflow",
    "section": "",
    "text": "Prerequisites\n\n\n\n\n\n\nR Basics\nThis is a quick example of a workflow working with data. It serves as a ‚Äúcarrot on a stick‚Äù that will hopefully get you through the more tedious parts of learning a programming language. If that doesn‚Äôt work, here‚Äôs a motivational penguin:",
    "crumbs": [
      "Materials",
      "02 - An Example Workflow"
    ]
  },
  {
    "objectID": "docs/02_workflow.html#installing-tidyverse",
    "href": "docs/02_workflow.html#installing-tidyverse",
    "title": "An Example Workflow",
    "section": "Installing tidyverse",
    "text": "Installing tidyverse\nThe tidyverse is a collection of R packages that gives us an extensive toolkit for working with data, from importing to transforming and visualising.\nTo install the tidyverse:\n\ninstall.packages(\"tidyverse\")\n\nIf you already installed tidyverse, doing this will just update the package.\nNow the package is installed on our system, we can load it with library(). In R basics we only worked in the console, so we have no real overview of what we‚Äôve done. You can see previous commands by pressing the up arrow ‚Üë on your keyboard, or look at the .Rhistory file, but a better way of keeping a record of the steps we take is by working in an R script.\nCreate a new script\nFile &gt; New File &gt; R Script\nThis will open a blank document. Here we can enter as many commands as we want to run. Pressing Enter will no longer run the command. Instead, you can run a command using Ctrl/Cmd + Enter. We can save the script (in scripts/) and load it any time we want to see what we‚Äôve done so far.\nAt the top of the script, load tidyverse.\n\nlibrary(tidyverse)",
    "crumbs": [
      "Materials",
      "02 - An Example Workflow"
    ]
  },
  {
    "objectID": "docs/02_workflow.html#importing-data",
    "href": "docs/02_workflow.html#importing-data",
    "title": "An Example Workflow",
    "section": "Importing data",
    "text": "Importing data\nUsually we would use the read_csv() function to import a local .csv file, but we can also give it a url (as long as it points to a .csv file).\n\nlibrary(tidyverse)\nsheep_data &lt;- read_csv(\"https://edu.nl/3hru6\")\n\nBarring any issues, we should now have the data available in R. A quick check with the head() function should allow us to see if anything went wrong.\n\nhead(sheep_data) # first 6 rows of the data\n\n# A tibble: 6 √ó 9\n  specID Taxon Site  Zone    Period group   GLl    Bd    Dl\n   &lt;dbl&gt; &lt;chr&gt; &lt;chr&gt; &lt;chr&gt;   &lt;chr&gt;  &lt;chr&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt;\n1      9 sheep DOR   Coastal IA2    Dor    31.5  21.0  18.2\n2     10 sheep DOR   Coastal IA2    Dor    29.3  19.5  16.8\n3     11 sheep DOR   Coastal IA2    Dor    28.2  17.4  15.9\n4     12 sheep DOR   Coastal IA2    Dor    29    19.4  16.5\n5     13 sheep DOR   Coastal IA2    Dor    29.8  18.7  16.4\n6     14 sheep DOR   Coastal IA2    Dor    30.6  20.3  16.6\n\n\nThe data are from the publication:\n\nThe contribution of Mediterranean connectivity to morphological variability in Iron Age sheep of the Eastern Mediterranean Sierra A. Harding, Angelos Hadjikoumis, Shyama Vermeersch, Roee Shafir, Nimrod Marom. bioRxiv 2022.12.24.521859; https://doi.org/10.1101/2022.12.24.521859\n\n\n\n\n\n\n\nData dictionary\n\n\n\n\n\n\n\n\n\n\n\n\ncolumn\ndescription\n\n\n\n\nspecID\nSpecimen ID\n\n\nTaxon\nTaxon\n\n\nSite\nSite code: DOR = Dor; KSN = Keisan; ABM = ABM (see group)\n\n\nZone\nZone: Coastal, inland, or Cyprus\n\n\nPeriod\nTime period: IA2 = Iron age; PER = Persian\n\n\ngroup\nDor = southern Levant sample Iron Age 2 Tel Dor; Keisan = southern Levant sample Iron Age 2 and Persian Tell Keisan; southern Levant sample ABM = Iron Age 2 Abel Beth Maacah; LTD = Cypriot sample from Archaic-Classical Lingrin tou Digeni\n\n\nGLl\nGreatest length lateral astragalus measurement\n\n\nBd\nGreatest breadth of distal end astragalus measurement\n\n\nDl\nGreatest depth lateral astragalus measurement",
    "crumbs": [
      "Materials",
      "02 - An Example Workflow"
    ]
  },
  {
    "objectID": "docs/02_workflow.html#visualising-the-data-with-ggplot2",
    "href": "docs/02_workflow.html#visualising-the-data-with-ggplot2",
    "title": "An Example Workflow",
    "section": "Visualising the data with ggplot2",
    "text": "Visualising the data with ggplot2\nFirst order of business is to explore the data set visually. To do that we will use the ggplot2 package, which is part of tidyverse.\nFor example, we could look at the relationship between the GLl and Bd measurements of the specimens.\n\n\n\n\n\n\n\n\n\nThe anatomy of a standard ggplot is:\nggplot(data = &lt;data&gt;, aes(&lt;mappings&gt;)) +\n    &lt;geometric function&gt; +\n    &lt;customisations&gt;\nTo start creating a plot, we use the ggplot() function and provide our data as the first argument.\n\nggplot(data = sheep_data)\n\n\n\n\n\n\n\n\nThis gives us a blank canvas on which we can create our visual masterpiece. Right now, however, all ggplot() knows is that we want to create a plot with our data, but that‚Äôs not enough information, and ggplot() isn‚Äôt a mind-reader. We need to tell ggplot which variables we want to plot by providing the mapping to the aesthetics of the plot.\n\nggplot(data = sheep_data, mapping = aes(x = GLl, y = Bd))\n\n\n\n\n\n\n\n\nBy providing the mapping, ggplot() now knows the bounds of the variables that we want to visualise, and can map the x and y aesthetics to our plot. Our code is pretty long, so to make it readable (to humans) we can expand it over multiple lines.\n\nggplot(\n  data = sheep_data,\n  mapping = aes(x = GLl, y = Bd)\n)\n\nFinally, we need to define a geometrical object to represent our data. For a scatter plot the geom we need is geom_point().\n\nggplot(\n  data = sheep_data, \n  mapping = aes(x = GLl, y = Bd)\n) +\n  geom_point()\n\n\n\n\n\n\n\n\nAlready we can see a relationship between the GLl and Bd of our sheep.\n\nAdding aesthetics\nWe can now already see that there is a positive relationship between the variables GLl and Bd. To take this relationship a step further, we can map a variable to colour.\n\nggplot(\n  data = sheep_data,\n  mapping = aes(x = GLl, y = Bd, colour = Zone)\n) +\n  geom_point()\n\n\n\n\n\n\n\n\nNow we can see the relationship (or lack thereof) in the measurements of sheep astragali between the Zones of occupation. To really drive home the relationship between the variables we can add a curve with geom_smooth(). We want to see the linear relationship so we will use method = \"lm\".\n\nggplot(\n  data = sheep_data,\n  aes(x = GLl, y = Bd, colour = Zone)\n) +\n  geom_point() +\n  geom_smooth(method = \"lm\")\n\n`geom_smooth()` using formula = 'y ~ x'\n\n\n\n\n\n\n\n\n\nThe confidence interval is making it kinda difficult to see the plot, so we can remove them with se = FALSE.\n\nggplot(\n  data = sheep_data,\n  aes(x = GLl, y = Bd, colour = Zone)\n) +\n  geom_point() +\n  geom_smooth(method = \"lm\", se = FALSE)\n\n`geom_smooth()` using formula = 'y ~ x'\n\n\n\n\n\n\n\n\n\nBecause we are providing the colour mapping in the ggplot(), all geoms inherit this value. If we just want to look at the overall relationship, we can move the colour mapping to geom_point(), which will allow us to keep the Phase colours and see the overall trendline for the data. We can reintroduce the confidence interval, too.\n\nggplot(\n  data = sheep_data,\n  aes(x = GLl, y = Bd)\n) +\n  geom_point(aes(colour = Zone)) +\n  geom_smooth(method = \"lm\")\n\n`geom_smooth()` using formula = 'y ~ x'\n\n\n\n\n\n\n\n\n\nNow for some finishing touches. There are many reasons why only using colours to convey information is a bad idea. Think about colour perception, and that publishers charge you extra for colour printing. So let‚Äôs make each Phase a different shape as well.\n\nggplot(\n  data = sheep_data,\n  aes(x = GLl, y = Bd)\n) +\n  geom_point(aes(colour = Zone, shape = Zone)) +\n  geom_smooth(method = \"lm\")\n\n`geom_smooth()` using formula = 'y ~ x'\n\n\n\n\n\n\n\n\n\nShapes can be resized using the size argument in the appropriate geom. Note we don‚Äôt want the size to be linked to an aesthetic, so we add the argument outside of aes().\n\nggplot(\n  sheep_data,\n  aes(x = GLl, y = Bd)\n) +\n  geom_point(aes(colour = Zone, shape = Zone), size = 2) + # increase the size\n  geom_smooth(method = \"lm\")\n\n`geom_smooth()` using formula = 'y ~ x'\n\n\n\n\n\n\n\n\n\nThen for the finishing touch, a new background and new axis labels.\n\nggplot(\n  sheep_data,\n  aes(x = GLl, y = Bd)\n) +\n  geom_point(\n    aes(colour = Zone, shape = Zone),\n    size = 2\n) +\n  geom_smooth(method = \"lm\") +\n  scale_colour_viridis_d(end = 0.8) +\n  theme_minimal() +\n  labs(\n    x = \"Greatest lateral length\",\n    y = \"Breadth of distal end\"\n  )\n\n`geom_smooth()` using formula = 'y ~ x'",
    "crumbs": [
      "Materials",
      "02 - An Example Workflow"
    ]
  },
  {
    "objectID": "docs/02_workflow.html#data-transformation-with-dplyr",
    "href": "docs/02_workflow.html#data-transformation-with-dplyr",
    "title": "An Example Workflow",
    "section": "Data Transformation with {dplyr}",
    "text": "Data Transformation with {dplyr}\nWe can start working on our data frame to find additional relationships. This will largely be done with functions from the tidyverse package dplyr.\n\nTransforming rows\nThe main functions used to operate on rows of a data frame are:\n\nfilter(): filter rows based on a condition\narrange(): arrange rows by ascending or descending values\n\nLet‚Äôs say we want to filter data that are related to the Site ‚ÄúKSN‚Äù.\n\nfilter(sheep_data, Site == \"KSN\")\n\n# A tibble: 18 √ó 9\n   specID Taxon Site  Zone    Period group    GLl    Bd    Dl\n    &lt;dbl&gt; &lt;chr&gt; &lt;chr&gt; &lt;chr&gt;   &lt;chr&gt;  &lt;chr&gt;  &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt;\n 1     25 sheep KSN   Coastal PER    Keisan  32    19.9  17.7\n 2     26 sheep KSN   Coastal PER    Keisan  30.7  19.7  18  \n 3     27 sheep KSN   Coastal IA2    Keisan  28.6  18.3  16.5\n 4     28 sheep KSN   Coastal IA2    Keisan  31.3  20.4  16.9\n 5     29 sheep KSN   Coastal PER    Keisan  29.5  18.3  15.8\n 6     31 sheep KSN   Coastal PER    Keisan  33    22.1  18.8\n 7     32 sheep KSN   Coastal PER    Keisan  32.2  21    18.3\n 8     33 sheep KSN   Coastal IA2    Keisan  32    20.4  17.1\n 9     34 sheep KSN   Coastal PER    Keisan  30.6  20.1  17.3\n10     35 sheep KSN   Coastal PER    Keisan  33.7  20.9  18.7\n11     36 sheep KSN   Coastal PER    Keisan  28.5  17.3  16  \n12     37 sheep KSN   Coastal PER    Keisan  32.8  21.7  18.7\n13     38 sheep KSN   Coastal IA2    Keisan  32.7  20.8  18.9\n14     39 sheep KSN   Coastal IA2    Keisan  30.1  19.3  17.4\n15     40 sheep KSN   Coastal IA2    Keisan  29.8  19.2  17.4\n16     41 sheep KSN   Coastal IA2    Keisan  30    19.1  16.6\n17     42 sheep KSN   Coastal IA2    Keisan  32    20.7  17.8\n18     43 sheep KSN   Coastal PER    Keisan  33.9  21.9  20.7\n\n\nNow say we‚Äôre only interested in rows related to ‚ÄúKSN‚Äù and ‚ÄúABM‚Äù. That means we want to filter all rows where Site is ‚ÄúKSN‚Äù or ‚ÄúABM‚Äù.\n\nfilter(\n  sheep_data,\n  Site == \"KSN\" | # or\n    Site == \"ABM\"\n)\n\n# A tibble: 105 √ó 9\n   specID Taxon Site  Zone    Period group    GLl    Bd    Dl\n    &lt;dbl&gt; &lt;chr&gt; &lt;chr&gt; &lt;chr&gt;   &lt;chr&gt;  &lt;chr&gt;  &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt;\n 1     25 sheep KSN   Coastal PER    Keisan  32    19.9  17.7\n 2     26 sheep KSN   Coastal PER    Keisan  30.7  19.7  18  \n 3     27 sheep KSN   Coastal IA2    Keisan  28.6  18.3  16.5\n 4     28 sheep KSN   Coastal IA2    Keisan  31.3  20.4  16.9\n 5     29 sheep KSN   Coastal PER    Keisan  29.5  18.3  15.8\n 6     31 sheep KSN   Coastal PER    Keisan  33    22.1  18.8\n 7     32 sheep KSN   Coastal PER    Keisan  32.2  21    18.3\n 8     33 sheep KSN   Coastal IA2    Keisan  32    20.4  17.1\n 9     34 sheep KSN   Coastal PER    Keisan  30.6  20.1  17.3\n10     35 sheep KSN   Coastal PER    Keisan  33.7  20.9  18.7\n# ‚Ñπ 95 more rows\n\n\nOr, in other words, we want all rows where the value of Site is not ‚ÄúDOR‚Äù.\n\nfiltered_site &lt;- filter(\n  sheep_data,\n  Site != \"DOR\"\n)\n\nWhat‚Äôs going on under the hood when we use filter, is the condition we create produces a Boolean vector that determines which rows should be kept.\n\nsheep_data$Site != \"DOR\"\n\n  [1] FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE\n [13] FALSE FALSE  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE\n [25]  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE\n [37]  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE\n [49]  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE\n [61]  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE\n [73]  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE\n [85]  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE\n [97]  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE\n[109]  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE\n\n\nWhenever a value is TRUE, that row will be retained, and whenever it is FALSE, that row will be removed.\nWe can then arrange the data frame in ascending or descending order of GLl.\n\narrange(filtered_site, GLl) # ascending\n\n# A tibble: 105 √ó 9\n   specID Taxon Site  Zone    Period group    GLl    Bd    Dl\n    &lt;dbl&gt; &lt;chr&gt; &lt;chr&gt; &lt;chr&gt;   &lt;chr&gt;  &lt;chr&gt;  &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt;\n 1     86 sheep ABM   Inland  IA2    ABM     27.4  17.3  14.7\n 2     97 sheep ABM   Inland  IA2    ABM     27.5  18.4  14.9\n 3    119 sheep ABM   Inland  IA2    ABM     27.8  18.4  14.9\n 4     67 sheep ABM   Inland  IA2    ABM     28    17.7  15.5\n 5     98 sheep ABM   Inland  IA2    ABM     28    18.6  15.1\n 6    127 sheep ABM   Inland  IA2    ABM     28.2  17.5  14.6\n 7    107 sheep ABM   Inland  IA2    ABM     28.3  18.7  15.2\n 8    134 sheep ABM   Inland  IA2    ABM     28.3  18.8  15.1\n 9     36 sheep KSN   Coastal PER    Keisan  28.5  17.3  16  \n10     68 sheep ABM   Inland  IA2    ABM     28.5  18.8  15.8\n# ‚Ñπ 95 more rows\n\narrange(filtered_site, desc(GLl)) # descending\n\n# A tibble: 105 √ó 9\n   specID Taxon Site  Zone    Period group    GLl    Bd    Dl\n    &lt;dbl&gt; &lt;chr&gt; &lt;chr&gt; &lt;chr&gt;   &lt;chr&gt;  &lt;chr&gt;  &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt;\n 1    126 sheep ABM   Inland  IA2    ABM     34.6  21.1  18.1\n 2    104 sheep ABM   Inland  IA2    ABM     34.4  21.4  17.9\n 3     43 sheep KSN   Coastal PER    Keisan  33.9  21.9  20.7\n 4     35 sheep KSN   Coastal PER    Keisan  33.7  20.9  18.7\n 5    129 sheep ABM   Inland  IA2    ABM     33.2  21.2  17.6\n 6     31 sheep KSN   Coastal PER    Keisan  33    22.1  18.8\n 7     37 sheep KSN   Coastal PER    Keisan  32.8  21.7  18.7\n 8     38 sheep KSN   Coastal IA2    Keisan  32.7  20.8  18.9\n 9     89 sheep ABM   Inland  IA2    ABM     32.6  19.2  16.7\n10     71 sheep ABM   Inland  IA2    ABM     32.4  20.1  16.9\n# ‚Ñπ 95 more rows\n\n\n\n\nTransforming columns\nThe most common functions for transforming columns are:\n\nmutate\nselect\n\nThe mutate function allows us to add variables. These can be variables with values that we define, or calculated from other variables. For example, we could create a variable containing the name of the dataset:\n\nmutate(filtered_site, dataset = \"Sheep Astragali\")\n\n# A tibble: 105 √ó 10\n   specID Taxon Site  Zone    Period group    GLl    Bd    Dl dataset        \n    &lt;dbl&gt; &lt;chr&gt; &lt;chr&gt; &lt;chr&gt;   &lt;chr&gt;  &lt;chr&gt;  &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;chr&gt;          \n 1     25 sheep KSN   Coastal PER    Keisan  32    19.9  17.7 Sheep Astragali\n 2     26 sheep KSN   Coastal PER    Keisan  30.7  19.7  18   Sheep Astragali\n 3     27 sheep KSN   Coastal IA2    Keisan  28.6  18.3  16.5 Sheep Astragali\n 4     28 sheep KSN   Coastal IA2    Keisan  31.3  20.4  16.9 Sheep Astragali\n 5     29 sheep KSN   Coastal PER    Keisan  29.5  18.3  15.8 Sheep Astragali\n 6     31 sheep KSN   Coastal PER    Keisan  33    22.1  18.8 Sheep Astragali\n 7     32 sheep KSN   Coastal PER    Keisan  32.2  21    18.3 Sheep Astragali\n 8     33 sheep KSN   Coastal IA2    Keisan  32    20.4  17.1 Sheep Astragali\n 9     34 sheep KSN   Coastal PER    Keisan  30.6  20.1  17.3 Sheep Astragali\n10     35 sheep KSN   Coastal PER    Keisan  33.7  20.9  18.7 Sheep Astragali\n# ‚Ñπ 95 more rows\n\n\nConsidering we only have this dataset, it‚Äôs not that informative. Instead, we could use the existing GLl and Dl variables to create a new variable containing the dimension index Dl and GLl of a specimen, and add it .after Dl in our data frame.\n\ndim_index &lt;- mutate(\n  filtered_site,\n  Dl_GLl = Dl / GLl * 100, .after = Dl\n)\n\n\n\nPipes\nWe are starting to produce a lot of intermediate data frames, which will end up taking up memory. Not a lot in this case, but if we were working with a large dataset, it might not be insignificant.\nThe pipe, |&gt; is an operator that allows us to string together multiple functions/operations on the same data, without the need to use the data argument in each step, and without the need to create intermediate objects.\n\n\n\n\n\n\nChoosing a pipe\n\n\n\n\n\nAs of R version 4.1.0, there are now two pipe operators. The ‚Äònative‚Äô pipe, |&gt; and the {magrittr} pipe, %&gt;%. They are very similar but differ in some key areas. For more information, see this blog post Here we will be using the native pipe since it doesn‚Äôt require installing additional packages (although {magrittr} is part of the tidyverse and many packages import the magrittr pipe).\n\n\n\nTo recreate the previous steps using the pipe:\n\nsheep_data |&gt; # we take our data, and then\n  filter(Site != \"DOR\") |&gt; # filter, and then\n  mutate(Dl_GLl = Dl / GLl * 100) # create a new variable\n\n# A tibble: 105 √ó 10\n   specID Taxon Site  Zone    Period group    GLl    Bd    Dl Dl_GLl\n    &lt;dbl&gt; &lt;chr&gt; &lt;chr&gt; &lt;chr&gt;   &lt;chr&gt;  &lt;chr&gt;  &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt;  &lt;dbl&gt;\n 1     25 sheep KSN   Coastal PER    Keisan  32    19.9  17.7   55.3\n 2     26 sheep KSN   Coastal PER    Keisan  30.7  19.7  18     58.6\n 3     27 sheep KSN   Coastal IA2    Keisan  28.6  18.3  16.5   57.7\n 4     28 sheep KSN   Coastal IA2    Keisan  31.3  20.4  16.9   54.0\n 5     29 sheep KSN   Coastal PER    Keisan  29.5  18.3  15.8   53.6\n 6     31 sheep KSN   Coastal PER    Keisan  33    22.1  18.8   57.0\n 7     32 sheep KSN   Coastal PER    Keisan  32.2  21    18.3   56.8\n 8     33 sheep KSN   Coastal IA2    Keisan  32    20.4  17.1   53.4\n 9     34 sheep KSN   Coastal PER    Keisan  30.6  20.1  17.3   56.5\n10     35 sheep KSN   Coastal PER    Keisan  33.7  20.9  18.7   55.5\n# ‚Ñπ 95 more rows\n\n\nThink of the pipe as the phrase ‚Äòand then‚Äô.\n\n\n\nGIPHY\n\n\nFirst we take our data frame, and then we filter() on the Site variable, and then we take the output (the data frame we originally called filtered_site) from that operation and pipe it to .data argument in the next mutate() operation to create the new variable Dl_GLl. The output of these operations is the same as the dim_index data frame.\nThe select() function allows us to‚Ä¶ well, select columns of the data frame that we want to keep (or not keep). We do this by providing the name(s) of the column(s) we want to select.\n\nselect(sheep_data, specID, Site, GLl, Dl)\n\n# A tibble: 119 √ó 4\n   specID Site    GLl    Dl\n    &lt;dbl&gt; &lt;chr&gt; &lt;dbl&gt; &lt;dbl&gt;\n 1      9 DOR    31.5  18.2\n 2     10 DOR    29.3  16.8\n 3     11 DOR    28.2  15.9\n 4     12 DOR    29    16.5\n 5     13 DOR    29.8  16.4\n 6     14 DOR    30.6  16.6\n 7     15 DOR    30.4  16.3\n 8     16 DOR    30.7  16.3\n 9     17 DOR    30.7  17.7\n10     19 DOR    31.3  18  \n# ‚Ñπ 109 more rows\n\n\nWe could also use the position of the columns:\n\nselect(sheep_data, 1, 3, 7, 9)\n\n# A tibble: 119 √ó 4\n   specID Site    GLl    Dl\n    &lt;dbl&gt; &lt;chr&gt; &lt;dbl&gt; &lt;dbl&gt;\n 1      9 DOR    31.5  18.2\n 2     10 DOR    29.3  16.8\n 3     11 DOR    28.2  15.9\n 4     12 DOR    29    16.5\n 5     13 DOR    29.8  16.4\n 6     14 DOR    30.6  16.6\n 7     15 DOR    30.4  16.3\n 8     16 DOR    30.7  16.3\n 9     17 DOR    30.7  17.7\n10     19 DOR    31.3  18  \n# ‚Ñπ 109 more rows\n\n\nNegating columns we don‚Äôt want is possible, and may sometimes be the easier option.\n\nselect(sheep_data, !c(Taxon, Zone, Period, group, Bd))\n\n# A tibble: 119 √ó 4\n   specID Site    GLl    Dl\n    &lt;dbl&gt; &lt;chr&gt; &lt;dbl&gt; &lt;dbl&gt;\n 1      9 DOR    31.5  18.2\n 2     10 DOR    29.3  16.8\n 3     11 DOR    28.2  15.9\n 4     12 DOR    29    16.5\n 5     13 DOR    29.8  16.4\n 6     14 DOR    30.6  16.6\n 7     15 DOR    30.4  16.3\n 8     16 DOR    30.7  16.3\n 9     17 DOR    30.7  17.7\n10     19 DOR    31.3  18  \n# ‚Ñπ 109 more rows\n\n\n\n\n\n\n\n\nWarning\n\n\n\nselect(sheep_data, !Taxon, !Zone, !Period, !group, !Bd)\nwill not work as expected.\n\n\nLet‚Äôs create a new, reduced data frame with the previous operations, and add an additional variable with a dimension index for Bd and Dl.\n\ndimension_data &lt;- sheep_data |&gt;\n  filter(Site != \"DOR\") |&gt;\n  select(specID, Site, GLl, Bd, Dl) |&gt;\n  mutate(\n    Dl_GLl = Dl / GLl * 100,\n    Bd_Dl = Bd / Dl * 100\n    )\n\n\n\nGrouping and summarising data\nIn many situations you‚Äôll want to summarise data and calculate summary statistics for different groups. The dplyr functions summarise/summarize and group_by will help you do that.\n\ndimension_data |&gt;\n  group_by(Site)\n\n# A tibble: 105 √ó 7\n# Groups:   Site [2]\n   specID Site    GLl    Bd    Dl Dl_GLl Bd_Dl\n    &lt;dbl&gt; &lt;chr&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt;  &lt;dbl&gt; &lt;dbl&gt;\n 1     25 KSN    32    19.9  17.7   55.3  112.\n 2     26 KSN    30.7  19.7  18     58.6  109.\n 3     27 KSN    28.6  18.3  16.5   57.7  111.\n 4     28 KSN    31.3  20.4  16.9   54.0  121.\n 5     29 KSN    29.5  18.3  15.8   53.6  116.\n 6     31 KSN    33    22.1  18.8   57.0  118.\n 7     32 KSN    32.2  21    18.3   56.8  115.\n 8     33 KSN    32    20.4  17.1   53.4  119.\n 9     34 KSN    30.6  20.1  17.3   56.5  116.\n10     35 KSN    33.7  20.9  18.7   55.5  112.\n# ‚Ñπ 95 more rows\n\n\n\n\n\n\n\n\nLinebreaks\n\n\n\nYou can‚Äôt just create a linebreak anywhere in your code. It should come after certain operators and symbols. It should come after the + symbol in a ggplot and after a pipe. The following will not work:\n\ndimension_data \n|&gt;  group_by(Zone)\n\n\n\nYou will likely not have noticed any difference in this data frame, but if you look at the top where the description is, you will see that it is now A tibble: 107 x 7 with Groups: Site [2]. This means that the tibble (or data frame) is grouped by the variable Site which has two groupings.\nOnce a data frame is grouped, we can perform specific operations on those groups, like calculating summary statistics.\n\ndimension_data |&gt;\n  group_by(Site) |&gt;\n  summarise(\n    mean_Dl_GLl = mean(Dl_GLl)\n  )\n\n# A tibble: 2 √ó 2\n  Site  mean_Dl_GLl\n  &lt;chr&gt;       &lt;dbl&gt;\n1 ABM          52.8\n2 KSN          56.5\n\n\nThis calculates the mean area for each group. We can add multiple arguments to summarise() to get the standard deviation and number of rows in each group:\n\ndimension_data |&gt;\n  group_by(Site) |&gt;\n  summarise(\n    n = n(),\n    mean_Dl_GLl = mean(Dl_GLl),\n    sd_DL_GLl = sd(Dl_GLl)\n  )\n\n# A tibble: 2 √ó 4\n  Site      n mean_Dl_GLl sd_DL_GLl\n  &lt;chr&gt; &lt;int&gt;       &lt;dbl&gt;     &lt;dbl&gt;\n1 ABM      87        52.8      1.58\n2 KSN      18        56.5      1.93\n\n\nWe can also visualise this with a box plot.\n\ndimension_data |&gt;\n  ggplot(aes(x = Site, y = Dl_GLl)) +\n    geom_boxplot()\n\n\n\n\n\n\n\n\nBox plots are notorious for hiding the distribution of data, so let‚Äôs add a violin plot with geom_violin() behind the box plots. If you‚Äôre lucky, sometimes the violin plots will look like pots. If you‚Äôre even luckier, the pot-like plots will be of data from actual pots!\n\ndimension_data |&gt;\n  ggplot(aes(x = Site, y = Dl_GLl)) +\n    geom_violin() + # will be displayed behind the box plots\n    geom_boxplot()    \n\n\n\n\n\n\n\n\nThe box plots are a little big, making it hard to see the violin plots behind them. We can use the width argument to adjust the width of the boxes.\n\ndimension_data |&gt;\n  ggplot(aes(x = Site, y = Dl_GLl)) +\n    geom_violin() +\n    geom_boxplot(width = 0.2)\n\n\n\n\n\n\n\n\nAdd some colour to the violins to contrast the two plot types, and change the background,\n\ndimension_data |&gt;\n  ggplot(aes(x = Site, y = Dl_GLl)) +\n    geom_violin(aes(fill = Site)) +\n    geom_boxplot(width = 0.2) +\n    theme_bw() +\n    theme(legend.position = \"none\") # and remove the redundant legend\n\n\n\n\n\n\n\n\net viol√†!\nThis masterpiece should be saved.\n\nggsave(\"figures/my-first-plot.png\")\n\nThis is a pretty idealised situation where the data are in a useable format. Real world data are rarely this easy to work with. I also removed the missing data from the example dataset. Hardly representative of a real-world archaeological dataset‚Ä¶",
    "crumbs": [
      "Materials",
      "02 - An Example Workflow"
    ]
  },
  {
    "objectID": "docs/06_transforming-data.html",
    "href": "docs/06_transforming-data.html",
    "title": "EDA: Transforming data with tidyverse",
    "section": "",
    "text": "Prerequisites\n\n\n\n\n\nCore + Visualising data\n\n\n\nProject organisation + Data cleaning\nSometimes cleaning our data is not enough, and we need to make further modifications. We can transform data using various functions from dplyr.\nAgain, let‚Äôs start a new script and call it 02_data-transform.R, saved to scripts/, and load tidyverse and here, and the data.\nlibrary(tidyverse)\nlibrary(here)\n\nmortuary_data &lt;- read_csv(here(\"data/mortuary_clean.csv\"))",
    "crumbs": [
      "Materials",
      "06 - Transforming Data"
    ]
  },
  {
    "objectID": "docs/06_transforming-data.html#subsetting-data",
    "href": "docs/06_transforming-data.html#subsetting-data",
    "title": "EDA: Transforming data with tidyverse",
    "section": "Subsetting data",
    "text": "Subsetting data\nThe two main functions for subsetting data are select() and filter().\nselect() allows us to select columns (yes, they nailed the name).\n\n# by name\nselect(mortuary_data, Golden_bead)\n\n# A tibble: 125 √ó 1\n   Golden_bead\n         &lt;dbl&gt;\n 1          NA\n 2          NA\n 3          NA\n 4           5\n 5           2\n 6           2\n 7          NA\n 8           2\n 9          NA\n10           2\n# ‚Ñπ 115 more rows\n\n# multiple names\nselect(mortuary_data, Golden_bead, Glass_bead)\n\n# A tibble: 125 √ó 2\n   Golden_bead Glass_bead\n         &lt;dbl&gt;      &lt;dbl&gt;\n 1          NA         NA\n 2          NA         NA\n 3          NA         NA\n 4           5         NA\n 5           2         NA\n 6           2         NA\n 7          NA          1\n 8           2          1\n 9          NA         NA\n10           2         NA\n# ‚Ñπ 115 more rows\n\n# or (as before) position\nselect(mortuary_data, c(22,23))\n\n# A tibble: 125 √ó 2\n   Golden_bead Glass_bead\n         &lt;dbl&gt;      &lt;dbl&gt;\n 1          NA         NA\n 2          NA         NA\n 3          NA         NA\n 4           5         NA\n 5           2         NA\n 6           2         NA\n 7          NA          1\n 8           2          1\n 9          NA         NA\n10           2         NA\n# ‚Ñπ 115 more rows\n\n\n\n\n\n\n\n\nFunction conflicts\n\n\n\n\n\nThere are many packages made for R, and only so many ways to name a function (with a name that makes sense‚Ä¶) When two packages have functions with the same name, this can create a conflict, since R will only be able to use one of the functions.\nFor example, if you have both dplyr and the MASS packages loaded, you will likely run into issues with the select() function, since both packages have a function by that name, but they serve different purposes and have different argument structures.\nIf R has decided to use the function from MASS, running the code select(clean_data, Glass_bead) will result in an error: Error in select(clean_data, Glass_bead) : unused argument (Glass_bead)\nTo resolve this you can specify the function namespace, namespace::function().\ndplyr::select(mortuary_data, Glass_bead)\nYou are essentially telling R that you specifically want to use select() from {dplyr}.\n\n\n\nYou may have noted that there was no need to surround the name of the column in quotes (\"Glass_bead\"). This is a tidyverse thing that I won‚Äôt go into any further. This may not be possible to do in other packages, where you could encounter an error in the form of object Glass_bead not found.\n\n\n\nArtwork by @allison_horst.\n\n\nfilter() allows you to filter entries/rows based on certain conditions. If we wanted to only show the data that are associated with graves prior European arrival (Phase == \"pre\"):\n\nfilter(mortuary_data, Phase == \"pre\")\n\n# A tibble: 29 √ó 55\n   Layer ID    Burial_axis Degree_axis Condition Length Width Height Pit  \n   &lt;dbl&gt; &lt;chr&gt;       &lt;dbl&gt;       &lt;dbl&gt;     &lt;dbl&gt;  &lt;dbl&gt; &lt;dbl&gt;  &lt;dbl&gt; &lt;chr&gt;\n 1     1 0               1         290         3    115    70     NA P9   \n 2     1 6               1         310         3     85    55     13 P038 \n 3     1 8               1         295         2    100    58     15 P038 \n 4     1 12              2          NA         3     NA    NA      9 P038 \n 5     1 21              1         290         2    105    47     22 P050 \n 6     1 25              1         295         1     95    45     37 P061 \n 7     1 27              1         315         3    115    80     20 P047 \n 8     1 28              1         305         2    105    45     28 P058 \n 9     1 32              1         305         1    140    58     50 P071 \n10     1 34              1         305         2    102    60     45 P018 \n# ‚Ñπ 19 more rows\n# ‚Ñπ 46 more variables: sampled &lt;chr&gt;, start_layer &lt;dbl&gt;, start_depth &lt;dbl&gt;,\n#   end_depth &lt;dbl&gt;, start_depth_sure &lt;chr&gt;, old_layer &lt;dbl&gt;, Phase &lt;chr&gt;,\n#   Coffin &lt;dbl&gt;, Straw_mat &lt;dbl&gt;, Gender &lt;dbl&gt;, Age &lt;chr&gt;, Agate_bead &lt;dbl&gt;,\n#   Golden_bead &lt;dbl&gt;, Glass_bead &lt;dbl&gt;, IndoPacific_bead &lt;dbl&gt;,\n#   Glass_earring &lt;dbl&gt;, Big_Metal_ring &lt;dbl&gt;, Small_Metal_ring &lt;dbl&gt;,\n#   Wide_Metal_ring &lt;dbl&gt;, Metal_ring &lt;dbl&gt;, Bell &lt;dbl&gt;, Knit &lt;lgl&gt;, ‚Ä¶\n\n\nWe can also filter by numeric values:\n\nfilter(mortuary_data, start_layer == 5) # only values that are equal to 5\n\n# A tibble: 9 √ó 55\n  Layer ID    Burial_axis Degree_axis Condition Length Width Height Pit  \n  &lt;dbl&gt; &lt;chr&gt;       &lt;dbl&gt;       &lt;dbl&gt;     &lt;dbl&gt;  &lt;dbl&gt; &lt;dbl&gt;  &lt;dbl&gt; &lt;chr&gt;\n1     1 0               1         290         3    115    70     NA P9   \n2     1 8               1         295         2    100    58     15 P038 \n3     1 12              2          NA         3     NA    NA      9 P038 \n4     1 40              1         280         1    100    55     20 P041 \n5     1 81              1          15         1    140    70     60 P086 \n6     1 83              2          NA         3     NA    NA     30 P117 \n7     1 85              1         300         1    110    55     36 P083 \n8     1 86              1         320         1     80    50     24 P082 \n9     1 115             1         310         2    110    55     20 P144 \n# ‚Ñπ 46 more variables: sampled &lt;chr&gt;, start_layer &lt;dbl&gt;, start_depth &lt;dbl&gt;,\n#   end_depth &lt;dbl&gt;, start_depth_sure &lt;chr&gt;, old_layer &lt;dbl&gt;, Phase &lt;chr&gt;,\n#   Coffin &lt;dbl&gt;, Straw_mat &lt;dbl&gt;, Gender &lt;dbl&gt;, Age &lt;chr&gt;, Agate_bead &lt;dbl&gt;,\n#   Golden_bead &lt;dbl&gt;, Glass_bead &lt;dbl&gt;, IndoPacific_bead &lt;dbl&gt;,\n#   Glass_earring &lt;dbl&gt;, Big_Metal_ring &lt;dbl&gt;, Small_Metal_ring &lt;dbl&gt;,\n#   Wide_Metal_ring &lt;dbl&gt;, Metal_ring &lt;dbl&gt;, Bell &lt;dbl&gt;, Knit &lt;lgl&gt;,\n#   fish_shape_knit &lt;dbl&gt;, Metal_string &lt;dbl&gt;, Metal_piece &lt;dbl&gt;, ‚Ä¶\n\nfilter(mortuary_data, start_layer != 5) # only values that are NOT equal to 5\n\n# A tibble: 81 √ó 55\n   Layer ID    Burial_axis Degree_axis Condition Length Width Height Pit  \n   &lt;dbl&gt; &lt;chr&gt;       &lt;dbl&gt;       &lt;dbl&gt;     &lt;dbl&gt;  &lt;dbl&gt; &lt;dbl&gt;  &lt;dbl&gt; &lt;chr&gt;\n 1     1 1               1         295         2    102    60     30 P051 \n 2     1 2               1         290         2    104    75     60 P051 \n 3     1 3               1         290         1    130    82     60 P050 \n 4     1 4               1         300         2    140    73     30 P038 \n 5     1 5               1         285         2     70    50     35 P050 \n 6     1 6               1         310         3     85    55     13 P038 \n 7     1 7               1         290         2    130    60     29 P028 \n 8     1 9               1         300         1    130    70     60 P052 \n 9     1 11              1         300         2     90    60     40 P060 \n10     1 15              1         290         2     95    60     27 P040 \n# ‚Ñπ 71 more rows\n# ‚Ñπ 46 more variables: sampled &lt;chr&gt;, start_layer &lt;dbl&gt;, start_depth &lt;dbl&gt;,\n#   end_depth &lt;dbl&gt;, start_depth_sure &lt;chr&gt;, old_layer &lt;dbl&gt;, Phase &lt;chr&gt;,\n#   Coffin &lt;dbl&gt;, Straw_mat &lt;dbl&gt;, Gender &lt;dbl&gt;, Age &lt;chr&gt;, Agate_bead &lt;dbl&gt;,\n#   Golden_bead &lt;dbl&gt;, Glass_bead &lt;dbl&gt;, IndoPacific_bead &lt;dbl&gt;,\n#   Glass_earring &lt;dbl&gt;, Big_Metal_ring &lt;dbl&gt;, Small_Metal_ring &lt;dbl&gt;,\n#   Wide_Metal_ring &lt;dbl&gt;, Metal_ring &lt;dbl&gt;, Bell &lt;dbl&gt;, Knit &lt;lgl&gt;, ‚Ä¶\n\nfilter(mortuary_data, start_layer &gt; 5) # only values that are greater than 5\n\n# A tibble: 33 √ó 55\n   Layer ID    Burial_axis Degree_axis Condition Length Width Height Pit  \n   &lt;dbl&gt; &lt;chr&gt;       &lt;dbl&gt;       &lt;dbl&gt;     &lt;dbl&gt;  &lt;dbl&gt; &lt;dbl&gt;  &lt;dbl&gt; &lt;chr&gt;\n 1     1 1               1         295         2    102    60     30 P051 \n 2     1 2               1         290         2    104    75     60 P051 \n 3     1 3               1         290         1    130    82     60 P050 \n 4     1 5               1         285         2     70    50     35 P050 \n 5     1 7               1         290         2    130    60     29 P028 \n 6     1 9               1         300         1    130    70     60 P052 \n 7     1 11              1         300         2     90    60     40 P060 \n 8     1 15              1         290         2     95    60     27 P040 \n 9     1 16              1         300         1     76    45     37 P072 \n10     1 17              1         292         2    100    60     30 P028 \n# ‚Ñπ 23 more rows\n# ‚Ñπ 46 more variables: sampled &lt;chr&gt;, start_layer &lt;dbl&gt;, start_depth &lt;dbl&gt;,\n#   end_depth &lt;dbl&gt;, start_depth_sure &lt;chr&gt;, old_layer &lt;dbl&gt;, Phase &lt;chr&gt;,\n#   Coffin &lt;dbl&gt;, Straw_mat &lt;dbl&gt;, Gender &lt;dbl&gt;, Age &lt;chr&gt;, Agate_bead &lt;dbl&gt;,\n#   Golden_bead &lt;dbl&gt;, Glass_bead &lt;dbl&gt;, IndoPacific_bead &lt;dbl&gt;,\n#   Glass_earring &lt;dbl&gt;, Big_Metal_ring &lt;dbl&gt;, Small_Metal_ring &lt;dbl&gt;,\n#   Wide_Metal_ring &lt;dbl&gt;, Metal_ring &lt;dbl&gt;, Bell &lt;dbl&gt;, Knit &lt;lgl&gt;, ‚Ä¶\n\nfilter(mortuary_data, start_layer &gt; 5 & start_layer &lt;= 12) # only values that are greater than 5 AND (&) less than, or equal to 12\n\n# A tibble: 31 √ó 55\n   Layer ID    Burial_axis Degree_axis Condition Length Width Height Pit  \n   &lt;dbl&gt; &lt;chr&gt;       &lt;dbl&gt;       &lt;dbl&gt;     &lt;dbl&gt;  &lt;dbl&gt; &lt;dbl&gt;  &lt;dbl&gt; &lt;chr&gt;\n 1     1 2               1         290         2    104    75     60 P051 \n 2     1 3               1         290         1    130    82     60 P050 \n 3     1 5               1         285         2     70    50     35 P050 \n 4     1 7               1         290         2    130    60     29 P028 \n 5     1 9               1         300         1    130    70     60 P052 \n 6     1 11              1         300         2     90    60     40 P060 \n 7     1 15              1         290         2     95    60     27 P040 \n 8     1 16              1         300         1     76    45     37 P072 \n 9     1 17              1         292         2    100    60     30 P028 \n10     1 18              1         280         2    110    70     24 P061 \n# ‚Ñπ 21 more rows\n# ‚Ñπ 46 more variables: sampled &lt;chr&gt;, start_layer &lt;dbl&gt;, start_depth &lt;dbl&gt;,\n#   end_depth &lt;dbl&gt;, start_depth_sure &lt;chr&gt;, old_layer &lt;dbl&gt;, Phase &lt;chr&gt;,\n#   Coffin &lt;dbl&gt;, Straw_mat &lt;dbl&gt;, Gender &lt;dbl&gt;, Age &lt;chr&gt;, Agate_bead &lt;dbl&gt;,\n#   Golden_bead &lt;dbl&gt;, Glass_bead &lt;dbl&gt;, IndoPacific_bead &lt;dbl&gt;,\n#   Glass_earring &lt;dbl&gt;, Big_Metal_ring &lt;dbl&gt;, Small_Metal_ring &lt;dbl&gt;,\n#   Wide_Metal_ring &lt;dbl&gt;, Metal_ring &lt;dbl&gt;, Bell &lt;dbl&gt;, Knit &lt;lgl&gt;, ‚Ä¶\n\nfilter(mortuary_data, start_layer &gt; 5 | start_layer &lt; 12) # only values that are greater than 5 OR (|) less than 12\n\n# A tibble: 90 √ó 55\n   Layer ID    Burial_axis Degree_axis Condition Length Width Height Pit  \n   &lt;dbl&gt; &lt;chr&gt;       &lt;dbl&gt;       &lt;dbl&gt;     &lt;dbl&gt;  &lt;dbl&gt; &lt;dbl&gt;  &lt;dbl&gt; &lt;chr&gt;\n 1     1 0               1         290         3    115    70     NA P9   \n 2     1 1               1         295         2    102    60     30 P051 \n 3     1 2               1         290         2    104    75     60 P051 \n 4     1 3               1         290         1    130    82     60 P050 \n 5     1 4               1         300         2    140    73     30 P038 \n 6     1 5               1         285         2     70    50     35 P050 \n 7     1 6               1         310         3     85    55     13 P038 \n 8     1 7               1         290         2    130    60     29 P028 \n 9     1 8               1         295         2    100    58     15 P038 \n10     1 9               1         300         1    130    70     60 P052 \n# ‚Ñπ 80 more rows\n# ‚Ñπ 46 more variables: sampled &lt;chr&gt;, start_layer &lt;dbl&gt;, start_depth &lt;dbl&gt;,\n#   end_depth &lt;dbl&gt;, start_depth_sure &lt;chr&gt;, old_layer &lt;dbl&gt;, Phase &lt;chr&gt;,\n#   Coffin &lt;dbl&gt;, Straw_mat &lt;dbl&gt;, Gender &lt;dbl&gt;, Age &lt;chr&gt;, Agate_bead &lt;dbl&gt;,\n#   Golden_bead &lt;dbl&gt;, Glass_bead &lt;dbl&gt;, IndoPacific_bead &lt;dbl&gt;,\n#   Glass_earring &lt;dbl&gt;, Big_Metal_ring &lt;dbl&gt;, Small_Metal_ring &lt;dbl&gt;,\n#   Wide_Metal_ring &lt;dbl&gt;, Metal_ring &lt;dbl&gt;, Bell &lt;dbl&gt;, Knit &lt;lgl&gt;, ‚Ä¶\n\n\nThis could be combined with select() to only show the relevant columns.\n\nselect(filter(mortuary_data, Phase == \"pre\"), ID, Golden_bead, Small_Metal_ring)\n\n# A tibble: 29 √ó 3\n   ID    Golden_bead Small_Metal_ring\n   &lt;chr&gt;       &lt;dbl&gt;            &lt;dbl&gt;\n 1 0              NA                1\n 2 6              NA                2\n 3 8              NA               NA\n 4 12              2                1\n 5 21              1                4\n 6 25             NA                3\n 7 27             NA                4\n 8 28             NA                2\n 9 32              6               NA\n10 34              4               NA\n# ‚Ñπ 19 more rows\n\n\nAnd now our code is very quickly becomming unreadable for humans‚Ä¶ It‚Äôs good practice to break up code to avoid having too many nested functions. In the above case we only have one function inside filter(), but that function has quite a few arguments. It‚Äôs best to create multiple steps.\n\npre_euro &lt;- filter(mortuary_data, Phase == \"pre\")\nselect(pre_euro, ID, Golden_bead, Small_Metal_ring)\n\n# A tibble: 29 √ó 3\n   ID    Golden_bead Small_Metal_ring\n   &lt;chr&gt;       &lt;dbl&gt;            &lt;dbl&gt;\n 1 0              NA                1\n 2 6              NA                2\n 3 8              NA               NA\n 4 12              2                1\n 5 21              1                4\n 6 25             NA                3\n 7 27             NA                4\n 8 28             NA                2\n 9 32              6               NA\n10 34              4               NA\n# ‚Ñπ 19 more rows\n\n\nFiltering on multiple variables:\n\npre_euro_cond2 &lt;- filter(mortuary_data, \n                        Phase == \"pre\",\n                        Condition == 2)\npre_euro_cond2_select &lt;- select(pre_euro_cond2, ID, Golden_bead, Small_Metal_ring)\n\nMean golden beads for Pit P061 with Condition 2 (partially disturbed).\n\nmean(pre_euro_cond2_select$Golden_bead, na.rm = T)\n\n[1] 2.125\n\nmean(pre_euro_cond2_select$Small_Metal_ring, na.rm = T)\n\n[1] 2.666667\n\n\n\n\n\n\n\n\nMissing data in R\n\n\n\nYou will often see the default setting for removing missing values as FALSE. This may seem strange. Why not just remove them by default for convenience? This is because of the R philosophy that no values should be silently removed. Either a function will not remove NAs, or it will give you a message informing you how many missing values/rows were removed.\n\n\nIf we wanted to also calculate the mean for the other conditions, we could repeat the above steps for Condition == 1 and Condition == 3, but that would quickly get tedious. There is an easier way to calculate multiple means and other descriptive statistics using the summarise() and group_by functions from {dplyr}.",
    "crumbs": [
      "Materials",
      "06 - Transforming Data"
    ]
  },
  {
    "objectID": "docs/06_transforming-data.html#groups",
    "href": "docs/06_transforming-data.html#groups",
    "title": "EDA: Transforming data with tidyverse",
    "section": "Groups",
    "text": "Groups\nGroups allow you to calculate statistics and perform operations on groups within the data. For example, we could group the data by the Phase variable and then perform a calculation on each level of Phase. The function to group data is group_by().\n\ngroup_by(.data = mortuary_data, Phase)\n\n# A tibble: 125 √ó 55\n# Groups:   Phase [6]\n   Layer ID    Burial_axis Degree_axis Condition Length Width Height Pit  \n   &lt;dbl&gt; &lt;chr&gt;       &lt;dbl&gt;       &lt;dbl&gt;     &lt;dbl&gt;  &lt;dbl&gt; &lt;dbl&gt;  &lt;dbl&gt; &lt;chr&gt;\n 1     1 0               1         290         3    115    70     NA P9   \n 2     1 1               1         295         2    102    60     30 P051 \n 3     1 2               1         290         2    104    75     60 P051 \n 4     1 3               1         290         1    130    82     60 P050 \n 5     1 4               1         300         2    140    73     30 P038 \n 6     1 5               1         285         2     70    50     35 P050 \n 7     1 6               1         310         3     85    55     13 P038 \n 8     1 7               1         290         2    130    60     29 P028 \n 9     1 8               1         295         2    100    58     15 P038 \n10     1 9               1         300         1    130    70     60 P052 \n# ‚Ñπ 115 more rows\n# ‚Ñπ 46 more variables: sampled &lt;chr&gt;, start_layer &lt;dbl&gt;, start_depth &lt;dbl&gt;,\n#   end_depth &lt;dbl&gt;, start_depth_sure &lt;chr&gt;, old_layer &lt;dbl&gt;, Phase &lt;chr&gt;,\n#   Coffin &lt;dbl&gt;, Straw_mat &lt;dbl&gt;, Gender &lt;dbl&gt;, Age &lt;chr&gt;, Agate_bead &lt;dbl&gt;,\n#   Golden_bead &lt;dbl&gt;, Glass_bead &lt;dbl&gt;, IndoPacific_bead &lt;dbl&gt;,\n#   Glass_earring &lt;dbl&gt;, Big_Metal_ring &lt;dbl&gt;, Small_Metal_ring &lt;dbl&gt;,\n#   Wide_Metal_ring &lt;dbl&gt;, Metal_ring &lt;dbl&gt;, Bell &lt;dbl&gt;, Knit &lt;lgl&gt;, ‚Ä¶\n\n\nAs you can see above, group_by() doesn‚Äôt seem to make any changes to the data, but if you look closely under the dimensions of the tibble at the top of the tibble itself, we now have # Groups: Phase [6].\nWe can also see the class() of the tibble will be ‚Äúgrouped_df‚Äù.\n\nclass(group_by(mortuary_data, Phase))\n\n[1] \"grouped_df\" \"tbl_df\"     \"tbl\"        \"data.frame\"",
    "crumbs": [
      "Materials",
      "06 - Transforming Data"
    ]
  },
  {
    "objectID": "docs/06_transforming-data.html#summarise",
    "href": "docs/06_transforming-data.html#summarise",
    "title": "EDA: Transforming data with tidyverse",
    "section": "summarise()",
    "text": "summarise()\nsummarise() (or summarize()) from dplyr is a very useful way of getting a wide range of descriptive statistics.\n\nsummarise(\n    .data = mortuary_data,\n    mean_golden = mean(Golden_bead, na.rm = T)\n)\n\n# A tibble: 1 √ó 1\n  mean_golden\n        &lt;dbl&gt;\n1        3.41\n\n\nLike mutate(), summarise() takes a .data argument first, and then name-value pairs for the new variable name and the function to compute the summary statistic(s). Unlike mutate(), the output of summarise is completely new data frame with one row per variable and one column per summary statistic. Above we created one column (mean_golden) and one row (the mean value of the Golden_bead variable).\nWe could also compute additional descriptives.\n\nsummarise(\n    mortuary_data,\n    mean_golden = mean(Golden_bead, na.rm = T),\n    median_golden = median(Golden_bead, na.rm = T),\n    sd_golden = sd(Golden_bead, na.rm = T)\n)\n\n# A tibble: 1 √ó 3\n  mean_golden median_golden sd_golden\n        &lt;dbl&gt;         &lt;dbl&gt;     &lt;dbl&gt;\n1        3.41             2      8.62\n\n\nThree name-value pairs equals three columns. To see how these descriptive statistics apply to different groups, such as the different phases of occupation in the Phase variable, we could use group_by function\n\nmortuary_data |&gt;\n  group_by(Phase) |&gt;\n  summarise(\n    mortuary_data,\n    mean_golden = mean(Golden_bead, na.rm = T),\n    median_golden = median(Golden_bead, na.rm = T),\n    sd_golden = sd(Golden_bead, na.rm = T)\n  )\n\nWarning: Returning more (or less) than 1 row per `summarise()` group was deprecated in\ndplyr 1.1.0.\n‚Ñπ Please use `reframe()` instead.\n‚Ñπ When switching from `summarise()` to `reframe()`, remember that `reframe()`\n  always returns an ungrouped data frame and adjust accordingly.\n\n\n`summarise()` has grouped output by 'Phase'. You can override using the\n`.groups` argument.\n\n\n# A tibble: 750 √ó 58\n# Groups:   Phase [6]\n   Phase Layer ID    Burial_axis Degree_axis Condition Length Width Height Pit  \n   &lt;chr&gt; &lt;dbl&gt; &lt;chr&gt;       &lt;dbl&gt;       &lt;dbl&gt;     &lt;dbl&gt;  &lt;dbl&gt; &lt;dbl&gt;  &lt;dbl&gt; &lt;chr&gt;\n 1 pre       1 0               1         290         3    115    70     NA P9   \n 2 euro      1 1               1         295         2    102    60     30 P051 \n 3 post      1 2               1         290         2    104    75     60 P051 \n 4 euro      1 3               1         290         1    130    82     60 P050 \n 5 euro      1 4               1         300         2    140    73     30 P038 \n 6 euro      1 5               1         285         2     70    50     35 P050 \n 7 pre       1 6               1         310         3     85    55     13 P038 \n 8 euro      1 7               1         290         2    130    60     29 P028 \n 9 pre       1 8               1         295         2    100    58     15 P038 \n10 post      1 9               1         300         1    130    70     60 P052 \n# ‚Ñπ 740 more rows\n# ‚Ñπ 48 more variables: sampled &lt;chr&gt;, start_layer &lt;dbl&gt;, start_depth &lt;dbl&gt;,\n#   end_depth &lt;dbl&gt;, start_depth_sure &lt;chr&gt;, old_layer &lt;dbl&gt;, Coffin &lt;dbl&gt;,\n#   Straw_mat &lt;dbl&gt;, Gender &lt;dbl&gt;, Age &lt;chr&gt;, Agate_bead &lt;dbl&gt;,\n#   Golden_bead &lt;dbl&gt;, Glass_bead &lt;dbl&gt;, IndoPacific_bead &lt;dbl&gt;,\n#   Glass_earring &lt;dbl&gt;, Big_Metal_ring &lt;dbl&gt;, Small_Metal_ring &lt;dbl&gt;,\n#   Wide_Metal_ring &lt;dbl&gt;, Metal_ring &lt;dbl&gt;, Bell &lt;dbl&gt;, Knit &lt;lgl&gt;, ‚Ä¶\n\n\nor the .by argument in summarise.\n\nsummarise(\n    mortuary_data,\n    mean_golden = mean(Golden_bead, na.rm = T),\n    median_golden = median(Golden_bead, na.rm = T),\n    sd_golden = sd(Golden_bead, na.rm = T),\n    .by = Phase\n)\n\n# A tibble: 6 √ó 4\n  Phase     mean_golden median_golden sd_golden\n  &lt;chr&gt;           &lt;dbl&gt;         &lt;dbl&gt;     &lt;dbl&gt;\n1 pre              7.33             2     16.7 \n2 euro             2.03             2      1.18\n3 post             2.25             2      1.26\n4 &lt;NA&gt;           NaN               NA     NA   \n5 chi              1                1     NA   \n6 disturbed      NaN               NA     NA   \n\n\n\n\n\n\n\n\nNote\n\n\n\nThe values NaN (Not a Number) mean that there were no values in Phase that could be calculated.\n\n\nPhase is a factor variable with five levels, ‚Äúchi‚Äù, ‚Äúdisturbed‚Äù, ‚Äúeuro‚Äù, ‚Äúpost‚Äù, ‚Äúpre‚Äù, indicating the phase of occupation at the site. By adding it as a grouping variable through the .by argument (or group_by function) we tell summarise() that we want separate summary statistics for each level.\nRemember how we used a bar plot to get Phase counts? We could also use summarise() with n().\n\nmortuary_data |&gt;\n  group_by(Phase) |&gt;\n  summarise(\n    n = n()\n  )\n\n# A tibble: 6 √ó 2\n  Phase         n\n  &lt;chr&gt;     &lt;int&gt;\n1 chi           4\n2 disturbed     8\n3 euro         44\n4 post          5\n5 pre          29\n6 &lt;NA&gt;         35\n\n\n\n\n\nmortuary_data |&gt;\n  ggplot(aes(x = Phase)) +\n    geom_bar()\n\n\n\n\n\n\n\n\nThis is equivalent to using the count() function.\n\nmortuary_data |&gt;\n  count(Phase)\n\n# A tibble: 6 √ó 2\n  Phase         n\n  &lt;chr&gt;     &lt;int&gt;\n1 chi           4\n2 disturbed     8\n3 euro         44\n4 post          5\n5 pre          29\n6 &lt;NA&gt;         35",
    "crumbs": [
      "Materials",
      "06 - Transforming Data"
    ]
  },
  {
    "objectID": "docs/06_transforming-data.html#across",
    "href": "docs/06_transforming-data.html#across",
    "title": "EDA: Transforming data with tidyverse",
    "section": "across()",
    "text": "across()\nIf we want to perform the same operation on multiple variables, we can use the across() function. This will allow us to apply a function (or multiple functions) across multiple columns.\n\n\n\nArtwork by @allison_horst.\n\n\nFor example, we can summarise all our bead variables grouped by Phase.\n\nmortuary_data |&gt;\n  group_by(Phase) |&gt;\n  summarise(\n    across(\n        c(Golden_bead, Glass_bead, IndoPacific_bead), \n        ~ mean(.x, na.rm = T)\n    )\n  )\n\n# A tibble: 6 √ó 4\n  Phase     Golden_bead Glass_bead IndoPacific_bead\n  &lt;chr&gt;           &lt;dbl&gt;      &lt;dbl&gt;            &lt;dbl&gt;\n1 chi              1           NaN            NaN  \n2 disturbed      NaN           NaN              1  \n3 euro             2.03          1            188. \n4 post             2.25        NaN           1526  \n5 pre              7.33          1            106  \n6 &lt;NA&gt;           NaN           NaN              2.5\n\n\nThe first argument in across() is the selection of columns to apply a function. The second argument is the function itself constructed as a lambda (~ mean(.x, na.rm = T)). The .x is a placeholder for the variables, so each of the selected variables will replace the .x in the mean function, producing a mean value for each of the variables supplied in the first argument of across().\nTyping individual variables can get very tedious very quickly. If the variables are adjacent we can use a colon :\n\nmortuary_data |&gt;\n  group_by(Phase) |&gt;\n  summarise(\n    across(\n        Agate_bead:Metal_piece, \n        ~ mean(.x, na.rm = T)\n    )\n  )\n\n# A tibble: 6 √ó 15\n  Phase     Agate_bead Golden_bead Glass_bead IndoPacific_bead Glass_earring\n  &lt;chr&gt;          &lt;dbl&gt;       &lt;dbl&gt;      &lt;dbl&gt;            &lt;dbl&gt;         &lt;dbl&gt;\n1 chi           NaN           1           NaN            NaN             NaN\n2 disturbed     NaN         NaN           NaN              1             NaN\n3 euro            4.76        2.03          1            188.            NaN\n4 post          NaN           2.25        NaN           1526             NaN\n5 pre             3.92        7.33          1            106             NaN\n6 &lt;NA&gt;           10         NaN           NaN              2.5             2\n# ‚Ñπ 9 more variables: Big_Metal_ring &lt;dbl&gt;, Small_Metal_ring &lt;dbl&gt;,\n#   Wide_Metal_ring &lt;dbl&gt;, Metal_ring &lt;dbl&gt;, Bell &lt;dbl&gt;, Knit &lt;dbl&gt;,\n#   fish_shape_knit &lt;dbl&gt;, Metal_string &lt;dbl&gt;, Metal_piece &lt;dbl&gt;\n\n\nBut we can rarely be so lucky. The method of selecting everything from Agate_bead to Metal_piece is also a little too error-prone. For example, did you notice that Metal_piece isn‚Äôt actually the last artefact column? And what if we had performed some sort of operation that rearranged columns? The risk of missing columns is quite high. Another way is to use selection helpers.",
    "crumbs": [
      "Materials",
      "06 - Transforming Data"
    ]
  },
  {
    "objectID": "docs/06_transforming-data.html#selection-helpers",
    "href": "docs/06_transforming-data.html#selection-helpers",
    "title": "EDA: Transforming data with tidyverse",
    "section": "Selection helpers",
    "text": "Selection helpers\nIf we want to select a range of variables in our data, or perform specific operations on multiple variables, there is a suite of functions known as ‚Äòselection helpers‚Äô\n\nif_any()\nif_all()\nstarts_with()\nends_with()\ncontains()\neverything()\n\nYou can see ?dplyr_tidy_select for a more complete list.\nIf the variable names contain a specific string, we can use\n\nstarts_with if the string is a prefix\nends_with if the string is a suffix\ncontains if the string is anywhere in the variable name\n\nFor example, if we wanted to select all bead variables, we could use both contains(\"bead\") and ends_with(\"bead\")\n\nmortuary_data |&gt;\n  group_by(Phase) |&gt;\n  summarise(\n    across(\n        contains(\"bead\"), \n        ~ mean(.x, na.rm = T)\n    )\n  )\n\n# A tibble: 6 √ó 5\n  Phase     Agate_bead Golden_bead Glass_bead IndoPacific_bead\n  &lt;chr&gt;          &lt;dbl&gt;       &lt;dbl&gt;      &lt;dbl&gt;            &lt;dbl&gt;\n1 chi           NaN           1           NaN            NaN  \n2 disturbed     NaN         NaN           NaN              1  \n3 euro            4.76        2.03          1            188. \n4 post          NaN           2.25        NaN           1526  \n5 pre             3.92        7.33          1            106  \n6 &lt;NA&gt;           10         NaN           NaN              2.5\n\n\nor\n\nmortuary_data |&gt;\n  group_by(Phase) |&gt;\n  summarise(\n    across(\n        ends_with(\"bead\"), \n        ~ mean(.x, na.rm = T)\n    )\n  )\n\n# A tibble: 6 √ó 5\n  Phase     Agate_bead Golden_bead Glass_bead IndoPacific_bead\n  &lt;chr&gt;          &lt;dbl&gt;       &lt;dbl&gt;      &lt;dbl&gt;            &lt;dbl&gt;\n1 chi           NaN           1           NaN            NaN  \n2 disturbed     NaN         NaN           NaN              1  \n3 euro            4.76        2.03          1            188. \n4 post          NaN           2.25        NaN           1526  \n5 pre             3.92        7.33          1            106  \n6 &lt;NA&gt;           10         NaN           NaN              2.5\n\n\nIt‚Äôs probably safer to use contains(\"bead\"), just in case not all the variables involving bead end in the suffix ‚Äô_bead‚Äô. On the other hand you will need to be aware if any of the variables contain the string ‚Äòbead‚Äô somewhere in the variable name without being associated with beads (for example, the code would include a variable named beadle).\n\n\n\n\n\n\nRegular expression\n\n\n\nIt‚Äôs also possible to construct a regular expression using matches().\n\n\nTo check which variables we are actually selecting, we can combine our selection helper with select().\n\nmortuary_data |&gt;\n  select(ends_with(\"bead\"))\n\n# A tibble: 125 √ó 4\n   Agate_bead Golden_bead Glass_bead IndoPacific_bead\n        &lt;dbl&gt;       &lt;dbl&gt;      &lt;dbl&gt;            &lt;dbl&gt;\n 1         NA          NA         NA               NA\n 2         NA          NA         NA               NA\n 3         NA          NA         NA               NA\n 4         NA           5         NA               NA\n 5         NA           2         NA               NA\n 6         NA           2         NA                1\n 7         NA          NA          1               NA\n 8         NA           2          1               NA\n 9          8          NA         NA                6\n10         NA           2         NA             1526\n# ‚Ñπ 115 more rows\n\n\n\n\n\n\n\n\nExercise\n\n\n\nSelect all columns with a Metal artefact. Then calculate the median for the counts grouped by Phase.\n?dplyr_tidy_select can help you find selection helpers.\n\n\n\n\n\n\nSolution\n\n\n\n\n\n\nmortuary_data |&gt;\n  group_by(Phase) |&gt; \n  summarise(\n    across(\n        contains(\"Metal\"),\n        ~ median(.x, na.rm = T)\n    )\n  )\n\n# A tibble: 6 √ó 8\n  Phase  Big_Metal_ring Small_Metal_ring Wide_Metal_ring Metal_ring Metal_string\n  &lt;chr&gt;           &lt;dbl&gt;            &lt;dbl&gt;           &lt;dbl&gt;      &lt;dbl&gt;        &lt;dbl&gt;\n1 chi                NA               NA              NA         NA           NA\n2 distu‚Ä¶              2               NA              NA         NA            2\n3 euro                2                2              NA          2            1\n4 post                7                1               2          3            1\n5 pre                 2                2               1          1            1\n6 &lt;NA&gt;               NA               NA              NA         NA            1\n# ‚Ñπ 2 more variables: Metal_piece &lt;dbl&gt;, Metal_plate &lt;dbl&gt;\n\n\nNot all variables have ‚ÄòMetal‚Äô as the first word, so contains() is the only way\nBy default contains() is case INsensitive, so here we would also include any variables with ‚Äúmetal‚Äù in the name. To change this you can add ignore.case = FALSE.\n\n\n\n\n\nTo perform multiple operations on multiple columns, we can use a list inside across().\n\nmortuary_data |&gt;\n  group_by(Phase) |&gt;\n  summarise(\n    across(\n        ends_with(\"bead\"),\n        list(\n          mean = ~ mean(.x, na.rm = T), \n          sd = ~ sd(.x, na.rm = T)\n        )\n    )\n  )\n\n# A tibble: 6 √ó 9\n  Phase     Agate_bead_mean Agate_bead_sd Golden_bead_mean Golden_bead_sd\n  &lt;chr&gt;               &lt;dbl&gt;         &lt;dbl&gt;            &lt;dbl&gt;          &lt;dbl&gt;\n1 chi                NaN            NA                1             NA   \n2 disturbed          NaN            NA              NaN             NA   \n3 euro                 4.76          4.05             2.03           1.18\n4 post               NaN            NA                2.25           1.26\n5 pre                  3.92          2.35             7.33          16.7 \n6 &lt;NA&gt;                10            13.9            NaN             NA   \n# ‚Ñπ 4 more variables: Glass_bead_mean &lt;dbl&gt;, Glass_bead_sd &lt;dbl&gt;,\n#   IndoPacific_bead_mean &lt;dbl&gt;, IndoPacific_bead_sd &lt;dbl&gt;\n\n\nLists are a type of R object that can contain all other types of R objects.\nFor example, here is a list that contains multiple types of objects:\n\nlist(\n  \"a_vector\" = mortuary_data$Width,\n  \"a_data_frame\" = mortuary_data,\n  \"a_function\" = mean,\n  \"etc\" = \"etc\"\n)\n\n$a_vector\n  [1] 70 60 75 82 73 50 55 60 58 70 60 NA 60 45 60 70 NA 60 47 70 55 70 45 70 80\n [26] 45 75 70 73 58 45 60 45 60 57 45 55 65 45 75 50 50 50 70 NA 70 75 60 70 56\n [51] NA 70 53 56 35 40 60 70 90 40 65 65 55 45 65 60 NA 60 65 70 75 40 60 40 45\n [76] 70 NA 65 55 50 60 70 45 NA NA NA 83 60 60 50 65 NA 50 60 70 85 55 70 NA 60\n[101] 53 60 55 70 47 60 40 55 40 20 50 25 46 78 55 55 60 45 NA NA 60 35 75 60 40\n\n$a_data_frame\n# A tibble: 125 √ó 55\n   Layer ID    Burial_axis Degree_axis Condition Length Width Height Pit  \n   &lt;dbl&gt; &lt;chr&gt;       &lt;dbl&gt;       &lt;dbl&gt;     &lt;dbl&gt;  &lt;dbl&gt; &lt;dbl&gt;  &lt;dbl&gt; &lt;chr&gt;\n 1     1 0               1         290         3    115    70     NA P9   \n 2     1 1               1         295         2    102    60     30 P051 \n 3     1 2               1         290         2    104    75     60 P051 \n 4     1 3               1         290         1    130    82     60 P050 \n 5     1 4               1         300         2    140    73     30 P038 \n 6     1 5               1         285         2     70    50     35 P050 \n 7     1 6               1         310         3     85    55     13 P038 \n 8     1 7               1         290         2    130    60     29 P028 \n 9     1 8               1         295         2    100    58     15 P038 \n10     1 9               1         300         1    130    70     60 P052 \n# ‚Ñπ 115 more rows\n# ‚Ñπ 46 more variables: sampled &lt;chr&gt;, start_layer &lt;dbl&gt;, start_depth &lt;dbl&gt;,\n#   end_depth &lt;dbl&gt;, start_depth_sure &lt;chr&gt;, old_layer &lt;dbl&gt;, Phase &lt;chr&gt;,\n#   Coffin &lt;dbl&gt;, Straw_mat &lt;dbl&gt;, Gender &lt;dbl&gt;, Age &lt;chr&gt;, Agate_bead &lt;dbl&gt;,\n#   Golden_bead &lt;dbl&gt;, Glass_bead &lt;dbl&gt;, IndoPacific_bead &lt;dbl&gt;,\n#   Glass_earring &lt;dbl&gt;, Big_Metal_ring &lt;dbl&gt;, Small_Metal_ring &lt;dbl&gt;,\n#   Wide_Metal_ring &lt;dbl&gt;, Metal_ring &lt;dbl&gt;, Bell &lt;dbl&gt;, Knit &lt;lgl&gt;, ‚Ä¶\n\n$a_function\nfunction (x, ...) \nUseMethod(\"mean\")\n&lt;bytecode: 0x563c5695b2c8&gt;\n&lt;environment: namespace:base&gt;\n\n$etc\n[1] \"etc\"\n\n\nEven with all the selection helpers, there‚Äôs really no convenient way to calculate the mean and standard deviation of artefact counts across all artefacts. We still need to use the range of columns.\n\nmortuary_data |&gt;\n  group_by(Phase) |&gt;\n  summarise(\n    across(\n        Agate_bead:Kendi_mouth,\n        list(\n          mean = ~ mean(.x, na.rm = T), \n          sd = ~ sd(.x, na.rm = T)\n        )\n    )\n  )\n\n# A tibble: 6 √ó 71\n  Phase     Agate_bead_mean Agate_bead_sd Golden_bead_mean Golden_bead_sd\n  &lt;chr&gt;               &lt;dbl&gt;         &lt;dbl&gt;            &lt;dbl&gt;          &lt;dbl&gt;\n1 chi                NaN            NA                1             NA   \n2 disturbed          NaN            NA              NaN             NA   \n3 euro                 4.76          4.05             2.03           1.18\n4 post               NaN            NA                2.25           1.26\n5 pre                  3.92          2.35             7.33          16.7 \n6 &lt;NA&gt;                10            13.9            NaN             NA   \n# ‚Ñπ 66 more variables: Glass_bead_mean &lt;dbl&gt;, Glass_bead_sd &lt;dbl&gt;,\n#   IndoPacific_bead_mean &lt;dbl&gt;, IndoPacific_bead_sd &lt;dbl&gt;,\n#   Glass_earring_mean &lt;dbl&gt;, Glass_earring_sd &lt;dbl&gt;,\n#   Big_Metal_ring_mean &lt;dbl&gt;, Big_Metal_ring_sd &lt;dbl&gt;,\n#   Small_Metal_ring_mean &lt;dbl&gt;, Small_Metal_ring_sd &lt;dbl&gt;,\n#   Wide_Metal_ring_mean &lt;dbl&gt;, Wide_Metal_ring_sd &lt;dbl&gt;,\n#   Metal_ring_mean &lt;dbl&gt;, Metal_ring_sd &lt;dbl&gt;, Bell_mean &lt;dbl&gt;, ‚Ä¶\n\n\nNow try to think of a way to create a bar plot that has all the bead-related variables.\nI haven‚Äôt included a solution because, to be honest, I‚Äôm not sure how to go about that. At least not with the data in their current form.\nThe selection helpers make our life easier, but having the artefact names as columns is making the visualisation and transformation of artefacts unnecessarily complicated.",
    "crumbs": [
      "Materials",
      "06 - Transforming Data"
    ]
  },
  {
    "objectID": "docs/06_transforming-data.html#tidy-data",
    "href": "docs/06_transforming-data.html#tidy-data",
    "title": "EDA: Transforming data with tidyverse",
    "section": "Tidy data",
    "text": "Tidy data\n\n‚ÄúTidy datasets are all alike, but every messy dataset is messy in its own way.‚Äù‚Äù\n‚Äì Hadley Wickham\n\nThe concept of tidy data and an early iteration of some tidyverse packages were introduced by Hadley Wickham in a 2014 paper. Tidy data is now one of the core philosophies of data science. If data structures are consistent, it‚Äôs easier to learn and create a unified set of tools for working with the data (such as the tidyverse packages).\nA tidy dataset has the following structure:\n\nEach variable is a column; for example, Phase of occupation\nEach observation is a row\nEach value is a cell; each cell has a single value\n\n\nIn our dataset we have each burial in a row, i.e., an observation. This is most likely because it is the easiest way to enter the data into the spreadsheet, but it arguably violates the principle of each row being an observation. And it would be much more useful if we had a column with artefact names where we could filter or group_by artefact, which we could then summarise.\nEnter pivot_longer().",
    "crumbs": [
      "Materials",
      "06 - Transforming Data"
    ]
  },
  {
    "objectID": "docs/06_transforming-data.html#pivoting",
    "href": "docs/06_transforming-data.html#pivoting",
    "title": "EDA: Transforming data with tidyverse",
    "section": "Pivoting",
    "text": "Pivoting\n\npivot_longer()\nIf we lengthen the data by creating a column that has the name of artefact and another column that has the count, we might have an easier time working with them.\n\n\n\nGIPHY\n\n\nBecause we want to lengthen the data we need the function pivot_longer() from {tidyr}. The main argument we need is cols which we use to specify which column(s) we are lengthening. We can start with two artefacts to visualise the process.\n\nartefact_long &lt;- mortuary_data |&gt;\n  select(ID, Phase, Agate_bead, Golden_bead) |&gt;\n  pivot_longer(Agate_bead:Golden_bead)\n\nLet‚Äôs check out the Golden_bead variable.\n\nartefact_long$Golden_bead\n\n\n\nWarning: Unknown or uninitialised column: `Golden_bead`.\n\n\nNULL\n\n\nThe column Golden_bead no longer exists. Instead we have two new columns, name and value which contain the name of our artefact and the count of that artefact for each burial, respectively. We also have a data frame with twice as many rows as our original, because now each row is an artefact, not a burial.\n\nartefact_long\n\n# A tibble: 250 √ó 4\n   ID    Phase name        value\n   &lt;chr&gt; &lt;chr&gt; &lt;chr&gt;       &lt;dbl&gt;\n 1 0     pre   Agate_bead     NA\n 2 0     pre   Golden_bead    NA\n 3 1     euro  Agate_bead     NA\n 4 1     euro  Golden_bead    NA\n 5 2     post  Agate_bead     NA\n 6 2     post  Golden_bead    NA\n 7 3     euro  Agate_bead     NA\n 8 3     euro  Golden_bead     5\n 9 4     euro  Agate_bead     NA\n10 4     euro  Golden_bead     2\n# ‚Ñπ 240 more rows\n\n\nNow we can apply it to all the artefacts. And to make things easier for ourselves we can also use the names_to and values_to arguments to define the names of our new variables instead of using the defaults name and value.\n\nartefact_long &lt;- mortuary_data |&gt;\n  pivot_longer(\n    Agate_bead:Metal_piece, # yes, we still need from x to y, but only once.\n    names_to = \"artefact\",\n    values_to = \"count\"\n  )\n\nNow that we have one row per artefact, the data frame is much longer, and some of the variables are repeated.\n\ndim(artefact_long)\n\n[1] 1750   43\n\n\nThis allows us to use summarise artefact counts without relying on across.\n\nartefact_long |&gt;\n  group_by(artefact) |&gt;\n  summarise(\n    mean = median(count, na.rm = T),\n    sd = sd(count, na.rm = T)\n  )\n\n# A tibble: 14 √ó 3\n   artefact          mean      sd\n   &lt;chr&gt;            &lt;dbl&gt;   &lt;dbl&gt;\n 1 Agate_bead         3.5   5.07 \n 2 Bell               1.5   0.816\n 3 Big_Metal_ring     2     1.57 \n 4 Glass_bead         1     0    \n 5 Glass_earring      2    NA    \n 6 Golden_bead        2     8.62 \n 7 IndoPacific_bead   5   553.   \n 8 Knit              NA    NA    \n 9 Metal_piece        1     0    \n10 Metal_ring         2     1.30 \n11 Metal_string       1     1.07 \n12 Small_Metal_ring   2     2.42 \n13 Wide_Metal_ring    1     0.408\n14 fish_shape_knit    1     0    \n\n\nThis is the same as we before, but with simpler code and a more readable output.\n\n\n\nartefact_long |&gt;\n  group_by(artefact, Phase) |&gt;\n  summarise(\n    mean = median(count, na.rm = T),\n    sd = sd(count, na.rm = T)\n  )\n\n`summarise()` has grouped output by 'artefact'. You can override using the\n`.groups` argument.\n\n\n# A tibble: 84 √ó 4\n# Groups:   artefact [14]\n   artefact   Phase      mean     sd\n   &lt;chr&gt;      &lt;chr&gt;     &lt;dbl&gt;  &lt;dbl&gt;\n 1 Agate_bead chi          NA NA    \n 2 Agate_bead disturbed    NA NA    \n 3 Agate_bead euro          3  4.05 \n 4 Agate_bead post         NA NA    \n 5 Agate_bead pre           4  2.35 \n 6 Agate_bead &lt;NA&gt;          2 13.9  \n 7 Bell       chi          NA NA    \n 8 Bell       disturbed    NA NA    \n 9 Bell       euro          1  0.548\n10 Bell       post         NA NA    \n# ‚Ñπ 74 more rows\n\n\n\n\n\n\nmortuary_data |&gt;\n  group_by(Phase) |&gt;\n  summarise(\n    across(\n        Agate_bead:Kendi_mouth,\n        list(\n          mean = ~ mean(.x, na.rm = T), \n          sd = ~ sd(.x, na.rm = T)\n        )\n    )\n  )\n\n# A tibble: 6 √ó 71\n  Phase     Agate_bead_mean Agate_bead_sd Golden_bead_mean Golden_bead_sd\n  &lt;chr&gt;               &lt;dbl&gt;         &lt;dbl&gt;            &lt;dbl&gt;          &lt;dbl&gt;\n1 chi                NaN            NA                1             NA   \n2 disturbed          NaN            NA              NaN             NA   \n3 euro                 4.76          4.05             2.03           1.18\n4 post               NaN            NA                2.25           1.26\n5 pre                  3.92          2.35             7.33          16.7 \n6 &lt;NA&gt;                10            13.9            NaN             NA   \n# ‚Ñπ 66 more variables: Glass_bead_mean &lt;dbl&gt;, Glass_bead_sd &lt;dbl&gt;,\n#   IndoPacific_bead_mean &lt;dbl&gt;, IndoPacific_bead_sd &lt;dbl&gt;,\n#   Glass_earring_mean &lt;dbl&gt;, Glass_earring_sd &lt;dbl&gt;,\n#   Big_Metal_ring_mean &lt;dbl&gt;, Big_Metal_ring_sd &lt;dbl&gt;,\n#   Small_Metal_ring_mean &lt;dbl&gt;, Small_Metal_ring_sd &lt;dbl&gt;,\n#   Wide_Metal_ring_mean &lt;dbl&gt;, Wide_Metal_ring_sd &lt;dbl&gt;,\n#   Metal_ring_mean &lt;dbl&gt;, Metal_ring_sd &lt;dbl&gt;, Bell_mean &lt;dbl&gt;, ‚Ä¶\n\n\n\n\nNow let‚Äôs try visualising the artefacts.\n\nartefact_long |&gt;\n  ggplot(aes(x = artefact, y = count)) +\n    geom_col()\n\nWarning: Removed 1521 rows containing missing values or values outside the scale range\n(`geom_col()`).\n\n\n\n\n\n\n\n\n\nSince IndoPacific_bead is so dominant, we could remove it.\n\nartefact_long |&gt;\n  filter(artefact != \"IndoPacific_bead\") |&gt;\n  ggplot(aes(x = artefact, y = count, fill = Phase)) +\n    geom_col()\n\nWarning: Removed 1433 rows containing missing values or values outside the scale range\n(`geom_col()`).\n\n\n\n\n\n\n\n\n\nThe large difference in absolute counts still makes it difficult to read the plot. It could make more sense to calculate the porportion of each artefact within each Phase.\n\npercent_artefacts &lt;- artefact_long |&gt;\n  group_by(Phase, artefact) |&gt;\n  summarise(\n    n = sum(count, na.rm = T)\n  ) |&gt;\n  group_by(Phase) |&gt;\n  mutate(percent = (n / sum(n)) * 100)\n\n`summarise()` has grouped output by 'Phase'. You can override using the\n`.groups` argument.\n\n percent_artefacts |&gt;\n  ggplot(aes(x = Phase, y = percent, fill = artefact)) +\n    geom_col()\n\n\n\n\n\n\n\n\nTo break down the above code. We are grouping by Phase and artefact because we want to calculate how many of each artefact are in a given Phase. Then we use sum within summarise() to do the actual calculation.\n\nartefact_long |&gt;\n  group_by(Phase, artefact) |&gt;\n  summarise(\n    n = sum(count, na.rm = T)\n  )\n\n`summarise()` has grouped output by 'Phase'. You can override using the\n`.groups` argument.\n\n\n# A tibble: 84 √ó 3\n# Groups:   Phase [6]\n   Phase artefact             n\n   &lt;chr&gt; &lt;chr&gt;            &lt;dbl&gt;\n 1 chi   Agate_bead           0\n 2 chi   Bell                 0\n 3 chi   Big_Metal_ring       0\n 4 chi   Glass_bead           0\n 5 chi   Glass_earring        0\n 6 chi   Golden_bead          1\n 7 chi   IndoPacific_bead     0\n 8 chi   Knit                 0\n 9 chi   Metal_piece          0\n10 chi   Metal_ring           0\n# ‚Ñπ 74 more rows\n\n\nThen we want to calculate the percentage each artefact makes up of the total count of artefacts within each Phase, so this time we only use Phase as a group and then calculate the percentage.\n\nartefact_long |&gt;\n  group_by(Phase, artefact) |&gt;\n  summarise(\n    n = sum(count, na.rm = T)\n  ) |&gt;\n  group_by(Phase) |&gt;\n  mutate(percent = (n / sum(n)) * 100) \n\n`summarise()` has grouped output by 'Phase'. You can override using the\n`.groups` argument.\n\n\n# A tibble: 84 √ó 4\n# Groups:   Phase [6]\n   Phase artefact             n percent\n   &lt;chr&gt; &lt;chr&gt;            &lt;dbl&gt;   &lt;dbl&gt;\n 1 chi   Agate_bead           0       0\n 2 chi   Bell                 0       0\n 3 chi   Big_Metal_ring       0       0\n 4 chi   Glass_bead           0       0\n 5 chi   Glass_earring        0       0\n 6 chi   Golden_bead          1     100\n 7 chi   IndoPacific_bead     0       0\n 8 chi   Knit                 0       0\n 9 chi   Metal_piece          0       0\n10 chi   Metal_ring           0       0\n# ‚Ñπ 74 more rows\n\n\nThis gives us the variables we need to produce the plot.\nAnother solution is to use panels in our plot, where each artefact gets it‚Äôs own mini plot.\n\nartefact_long |&gt;\n  ggplot(aes(x = Phase, y = count)) +\n    geom_col() +\n    facet_wrap(~ artefact) # a panel per artefact\n\nWarning: Removed 1521 rows containing missing values or values outside the scale range\n(`geom_col()`).\n\n\n\n\n\n\n\n\n\nEach panel will have the same y-axis limits, which makes it difficult to see anything other than IndoPacific_bead. Instead we can give each panel its own limits based on the values.\n\nartefact_long |&gt;\n  ggplot(aes(x = Phase, y = count, fill = Phase)) +\n    geom_col() +\n    facet_wrap(~ artefact, scales = \"free_y\")\n\nWarning: Removed 1521 rows containing missing values or values outside the scale range\n(`geom_col()`).\n\n\n\n\n\n\n\n\n\nWe could also select specific artefacts we would like to focus on. To do this we will need to filter the artefact column. Since filter is not a selecting function, we cannot use selection helpers.\n\nartefact_long |&gt;\n  filter(contains(\"metal\"))\n\n\n\nError in filter(artefact_long, contains(\"bead\")) : \n  ‚Ñπ In argument: `contains(\"bead\")`.\nCaused by error:\n! `contains()` must be used within a *selecting* function.\n‚Ñπ See &lt;https://tidyselect.r-lib.org/reference/faq-selection-context.html&gt; for\n  details.\n\n\nInstead we need to rely on a condition that evaluates to TRUE or FALSE. Rather than using artefact == \"name of artefact\" multiple times, we can use functions from the stringr package to detect patterns. Specifically str_detect() allows us to identify a string in a variable.\n\nartefact_long |&gt;\n  filter(str_detect(artefact, \"bead\")) |&gt;\n  ggplot(aes(x = artefact, y = count)) +\n    geom_col()\n\nWarning: Removed 382 rows containing missing values or values outside the scale range\n(`geom_col()`).\n\n\n\n\n\n\n\n\n\nstr_detect(), as the name implies, detects whether the string ‚Äòbead‚Äô exists in the artefact variable, and returns TRUE if it does, and FALSE if it does not. Exactly what we need for the filter() function.\n\nstr_detect(artefact_long$artefact, \"bead\")[1:100] # limit the output to 100 values\n\n  [1]  TRUE  TRUE  TRUE  TRUE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE\n [13] FALSE FALSE  TRUE  TRUE  TRUE  TRUE FALSE FALSE FALSE FALSE FALSE FALSE\n [25] FALSE FALSE FALSE FALSE  TRUE  TRUE  TRUE  TRUE FALSE FALSE FALSE FALSE\n [37] FALSE FALSE FALSE FALSE FALSE FALSE  TRUE  TRUE  TRUE  TRUE FALSE FALSE\n [49] FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE  TRUE  TRUE  TRUE  TRUE\n [61] FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE  TRUE  TRUE\n [73]  TRUE  TRUE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE\n [85]  TRUE  TRUE  TRUE  TRUE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE\n [97] FALSE FALSE  TRUE  TRUE\n\n\nThe long format of the data also makes it easier to summarise() the counts of each artefact by Phase.\n\nsummarise(artefact_long,\n          count = sum(count, na.rm = T),\n          .by = c(Phase, artefact))\n\n# A tibble: 84 √ó 3\n   Phase artefact         count\n   &lt;chr&gt; &lt;chr&gt;            &lt;dbl&gt;\n 1 pre   Agate_bead          47\n 2 pre   Golden_bead         88\n 3 pre   Glass_bead           1\n 4 pre   IndoPacific_bead  1166\n 5 pre   Glass_earring        0\n 6 pre   Big_Metal_ring      39\n 7 pre   Small_Metal_ring    36\n 8 pre   Wide_Metal_ring      5\n 9 pre   Metal_ring           1\n10 pre   Bell                 0\n# ‚Ñπ 74 more rows\n\n\nAnd we can create a new data frame with the total artefact count for each burial.\n\ntotal_artefact_count &lt;- artefact_long |&gt;\n  group_by(ID, Phase, Age, Gender) |&gt;\n  summarise(\n    total_count = sum(count, na.rm = T)\n  ) |&gt;\n  ungroup()\n\n`summarise()` has grouped output by 'ID', 'Phase', 'Age'. You can override\nusing the `.groups` argument.\n\n\n\ntotal_artefact_count\n\n# A tibble: 125 √ó 5\n   ID    Phase Age   Gender total_count\n   &lt;chr&gt; &lt;chr&gt; &lt;chr&gt;  &lt;dbl&gt;       &lt;dbl&gt;\n 1 0     pre   &lt;NA&gt;      NA           3\n 2 1     euro  4         NA           0\n 3 100   euro  2         NA           3\n 4 101   pre   5          1           1\n 5 102   pre   4          3           9\n 6 103   pre   4         NA           1\n 7 104   pre   2         NA           2\n 8 105   &lt;NA&gt;  &lt;NA&gt;       2           0\n 9 106   &lt;NA&gt;  &lt;NA&gt;      NA           0\n10 107   euro  7          4          19\n# ‚Ñπ 115 more rows\n\n\nAnd export it as a .csv file to our data/ folder.\n\nwrite_csv(total_artefact_count, here(\"data/total-artefact-count.csv\"))\n\n\n\npivot_wider()\nThe complement to pivot_longer() is pivot_wider(). We could use it to go back to the original data frame. Instead of moving existing column names to a column, and existing values to another column, we want to move names from a column and values from another column.\n\nartefact_wide &lt;- artefact_long |&gt;\n  pivot_wider(names_from = artefact, values_from = count)\n\nAnd we are back to where we started.\n\ndim(artefact_wide) == dim(mortuary_data) # we are testing if this statement is TRUE\n\n[1] TRUE TRUE",
    "crumbs": [
      "Materials",
      "06 - Transforming Data"
    ]
  },
  {
    "objectID": "docs/00_install-r-rstudio.html",
    "href": "docs/00_install-r-rstudio.html",
    "title": "RchaeoStats",
    "section": "",
    "text": "To work with R and RStudio, you must first install R. R Studio is the integrated development environment (IDE) and runs R. You can use R without RStudio, but you can‚Äôt use RStudio without R.\n\n\n\nWindowsMacOSLinux\n\n\nDownload the latest version of R (R-X.Y.Z-win.exe) on CRAN.\nRun the R-X.Y.Z-win.exe file and follow the installation instructions (defaults are fine)\nDownload the latest version of RStudio select the .exe file associated with OS Windows 10/11\n\n\nDownload the latest version of R (R-X.Y.Z-win.exe) on CRAN.\n\n\n\n\n\n\nImportant\n\n\n\nIf your Mac is running an M1/M2 chip, then you need the arm architecture (R-X.Y.Z-arm64.pkg).\nIf your Mac is running an Intel chip, then you need the x86 architecture (R-X.Y.Z-x86_64.pkg).\nFind out which one using this How-To Geek post.\n\n\nSelect the .pkg file appropriate for you Mac chip and macOS version.\nDownload the latest version of RStudio select the .dmg file associated with OS macOS 11+.\n\n\nDownload the latest version of R on CRAN.\nSelect your distro and follow the instructions.\nDownload the latest version of RStudio for your distro (e.g.¬†.deb for Ubuntu/Debian).\n\n\n\nAfter installing R and RStudio, you will only ever need to open RStudio, as it will run R for you.",
    "crumbs": [
      "Materials",
      "00 - Getting Started"
    ]
  },
  {
    "objectID": "docs/00_install-r-rstudio.html#installing-r-and-rstudio",
    "href": "docs/00_install-r-rstudio.html#installing-r-and-rstudio",
    "title": "RchaeoStats",
    "section": "",
    "text": "To work with R and RStudio, you must first install R. R Studio is the integrated development environment (IDE) and runs R. You can use R without RStudio, but you can‚Äôt use RStudio without R.\n\n\n\nWindowsMacOSLinux\n\n\nDownload the latest version of R (R-X.Y.Z-win.exe) on CRAN.\nRun the R-X.Y.Z-win.exe file and follow the installation instructions (defaults are fine)\nDownload the latest version of RStudio select the .exe file associated with OS Windows 10/11\n\n\nDownload the latest version of R (R-X.Y.Z-win.exe) on CRAN.\n\n\n\n\n\n\nImportant\n\n\n\nIf your Mac is running an M1/M2 chip, then you need the arm architecture (R-X.Y.Z-arm64.pkg).\nIf your Mac is running an Intel chip, then you need the x86 architecture (R-X.Y.Z-x86_64.pkg).\nFind out which one using this How-To Geek post.\n\n\nSelect the .pkg file appropriate for you Mac chip and macOS version.\nDownload the latest version of RStudio select the .dmg file associated with OS macOS 11+.\n\n\nDownload the latest version of R on CRAN.\nSelect your distro and follow the instructions.\nDownload the latest version of RStudio for your distro (e.g.¬†.deb for Ubuntu/Debian).\n\n\n\nAfter installing R and RStudio, you will only ever need to open RStudio, as it will run R for you.",
    "crumbs": [
      "Materials",
      "00 - Getting Started"
    ]
  },
  {
    "objectID": "docs/00_install-r-rstudio.html#updating-r-and-rstudio",
    "href": "docs/00_install-r-rstudio.html#updating-r-and-rstudio",
    "title": "RchaeoStats",
    "section": "Updating R and RStudio",
    "text": "Updating R and RStudio\nYou can check for updates in RStudio by going to Help &gt; Check for updates.\nTo update R, you will have to go to CRAN and repeat the steps from above. To check which R version you have, type version$version.string in the console.",
    "crumbs": [
      "Materials",
      "00 - Getting Started"
    ]
  },
  {
    "objectID": "docs/04_cleaning-data.html",
    "href": "docs/04_cleaning-data.html",
    "title": "Cleaning data with tidyverse",
    "section": "",
    "text": "Prerequisites\n\n\n\n\n\n\n\nR basics + Example workflow + Project organisation\n\n\n\nProject organisation\nData cleaning often takes up a large portion of an analysis, especially if the raw data were not collected with the intention to analyse the data in R.\nIf the raw data are collected with tidy data principles in mind (discussed briefly in EDA: Transforming data with tidyverse), this will greatly reduce the steps needed to clean the data, and allow you to move quickly on to the more fun visualisations and modelling. That being said, cleaning data serves as a nice learning tool to introduce various concepts of the R programming language.",
    "crumbs": [
      "Materials",
      "04 - Cleaning Data"
    ]
  },
  {
    "objectID": "docs/04_cleaning-data.html#downloading-data",
    "href": "docs/04_cleaning-data.html#downloading-data",
    "title": "Cleaning data with tidyverse",
    "section": "Downloading data",
    "text": "Downloading data\nThe dataset from An Example Workflow was already cleaned and in .csv format, which is why we were able to read it directly into R using read_csv() and the url. This is not the case with for the .xlsx file we will be working with here, and the read_xlsx() function we will use does not work with a url as the path to the file.\nWe could go to the site, download it manually, and place it in the data-raw/ folder; but, in the interest of reproducibility, we will create a script to download and clean the data.\nCreate a new R script called mortuary_data.R, and save it in data-raw/. We can then use the download.file() function to download the dataset using the url for the xlsx download: https://edu.nl/x4bqv.\nWe will also load tidyverse and here at the top of the script.\n\nlibrary(tidyverse)\nlibrary(here)\n\nxlsx_url &lt;- \"https://edu.nl/x4bqv\"\ndownload.file(url = xlsx_url, destfile = \"data-raw/mortuary-data.xlsx\", mode = \"wb\")\n\nRun the code and we should see a file called mortuary-data.xlsx in the data-raw/ folder.\n\n\n\n\n\n\nImportant\n\n\n\nThere is NO reason to edit any of the files in the data-raw folder manually.\nRaw data should not be modified, and derived data are produced from the analysis script, so they also shouldn‚Äôt be edited manually.\n\n\n\n\n\n\n\n\nData dictionary\n\n\n\n\n\n\n\n\n\n\n\n\nVariable\nDescription\n\n\n\n\nLayer\nLayer of the grave. 1 = Upper culture layer; 2 = Lower culture layer.\n\n\nID\nUnique identifier of burials\n\n\nBurial_axis\nNot sure. Not relevant\n\n\nDegree_axis\nNot sure. Not relevant\n\n\nCondition\nCondition of the burial. 1 = complete; 2 = partial disturbed; 3 = severe disturbed; 4 = unidentified.\n\n\nGender\nBiological sex of the skeletal remains. 1 = Male; 2 = Probable Male; 3 = Female; 4 = Probable Female.\n\n\nAge\nAge-at-death of the skeletal remains. 1 = infant (0-2 years); 2 = child (3-12 years); 3 = teenager (12-20 years); 4 = young adult(20-35 years); 5 = middle adult (35-50 years); 6 = old adult (50+); 7 = adult (20+); 8 = approximate adult\n\n\nLength\nLength of burial\n\n\nWidth\nWidth of burial\n\n\nHeight\nHeight of burial",
    "crumbs": [
      "Materials",
      "04 - Cleaning Data"
    ]
  },
  {
    "objectID": "docs/04_cleaning-data.html#importing-data",
    "href": "docs/04_cleaning-data.html#importing-data",
    "title": "Cleaning data with tidyverse",
    "section": "Importing data",
    "text": "Importing data\nTo import a .xlsx file, we will need to use the readxl package, which is part of the tidyverse. From the readxl package, we need the function read_xlsx(). This allows us to import data from a .xlsx file. We will use the here() function to ensure our filepath is relative to the project root.\nWe also need to assign it to an object using the assignment operator, &lt;- to store the data in memory.\n\nraw_data &lt;- read_xlsx(path = here(\"data-raw/mortuary-data.xlsx\"))\n\n\n\n\n\n\n\nOrganising your script\n\n\n\nIt‚Äôs a good idea to organise your script, so you (or someone else) can easily read it at a later point. One useful way of organising a script is by adding headers.\nCode &gt; Insert Section‚Ä¶\nor Ctrl + Shift + R\n\n\nThe raw_data object we have created is a tibble, which is a structure for tabulated data specific to tidyverse. It is a tibble because we used the read_xlsx() function from the readxl package, which is part of tidyverse. If we had used a base R function like read.csv(), we would have created a data frame. Base R does not have a function to import .xlsx files, though, so we needed an additional package for that. Tibbles and data frames are largely interchangeable.\nThe main thing you need to know is where you are storing the data file. Ideally, this will be in a folder in the root of your project called data. We have made two separate folders (data/ and data-raw/) to distinguish between raw and processed data.\nLet‚Äôs try to plot the Height and Weight of the burials and group by Phase.\n\nraw_data |&gt;\n  ggplot(aes(x = Width, y = Height, col = Phase)) +\n    geom_point()\n\nWe get the error object 'Height' not found.\n\n\n\n\n\n\nConsole messages\n\n\n\nThere are three types of console messages that you will frequently encounter: messages, warnings, and errors.\nMessages are just helpful messages to give you some extra information about the code you just ran.\nWarnings are messages that tell you that, while your code did run successfully, there may have been some problems with the output that you should double check.\nErrors mean your code did not run successfully.\n\n\nWeird‚Ä¶ There should be a variable called Height. Let‚Äôs take a look:\n\nnames(raw_data)\n\n [1] \"Layer\"             \"ID\"                \"Burial_axis\"      \n [4] \"Degree_axis\"       \"Condition\"         \"Length\"           \n [7] \"Width\"             \"Hight\"             \"Pit\"              \n[10] \"sampled\"           \"start_layer\"       \"start_depth\"      \n[13] \"end_depth\"         \"start_depth_sure\"  \"old_layer\"        \n[16] \"Phase\"             \"Coffin\"            \"Straw_mat\"        \n[19] \"Gender\"            \"Age\"               \"Agate_bead\"       \n[22] \"Golden_bead\"       \"Glass_bead\"        \"Indo-Pacific_bead\"\n[25] \"Glass_earring\"     \"Big_Metal_ring\"    \"Small_Metal_ring\" \n[28] \"Wide_Metal_ring\"   \"Metal_ring\"        \"Bell\"             \n[31] \"Knit\"              \"fish_shape_knit\"   \"Metal_string\"     \n[34] \"Metal_piece\"       \"Metal_plate\"       \"Hair_pin\"         \n[37] \"Niddle\"            \"Bone_plate\"        \"Comb\"             \n[40] \"Coin\"              \"Porcelain_bowl\"    \"Porcelain_vessel\" \n[43] \"Porcelain_vase\"    \"Blue_glazed_vase\"  \"Brown_glazed_vase\"\n[46] \"Porcelain_piece\"   \"Ceramic_vase\"      \"Iron_artifact\"    \n[49] \"Stone_artifact\"    \"Grinding_stone\"    \"Stone_hammer\"     \n[52] \"Stone_axe\"         \"Wood_artifact\"     \"Anping_jar\"       \n[55] \"Kendi_mouth\"      \n\n\nIt looks like there‚Äôs a typo in the Height variable. Easy fix:\n\nraw_data |&gt;\n  ggplot(aes(x = Width, y = Hight, col = Phase)) + # change to Hight\n    geom_point()\n\nWarning: Removed 1 row containing missing values or values outside the scale range\n(`geom_point()`).\n\n\n\n\n\n\n\n\n\nWe are creating a plot, but something is not quite right. This is what we‚Äôre after:\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nExercise\n\n\n\nSpot the problem(s) with the plot.\n\n\n\n\n\n\nSolution\n\n\n\n\n\nThe Width variable is being treated as a categorical variable. This can be seen on the x-axis as well as the fact that we are unable to calculate the regression line.\nThere are also a number of NAs in both the Hight and Phase variables, which indicate missing values.\n\n\n\n\n\nIt looks like we need to take a closer look at the data.\n\nstr(raw_data)\n\ntibble [125 √ó 55] (S3: tbl_df/tbl/data.frame)\n $ Layer            : num [1:125] 1 1 1 1 1 1 1 1 1 1 ...\n $ ID               : chr [1:125] \"0\" \"1\" \"2\" \"3\" ...\n $ Burial_axis      : num [1:125] 1 1 1 1 1 1 1 1 1 1 ...\n $ Degree_axis      : num [1:125] 290 295 290 290 300 285 310 290 295 300 ...\n $ Condition        : num [1:125] 3 2 2 1 2 2 3 2 2 1 ...\n $ Length           : chr [1:125] \"115\" \"102\" \"104\" \"130\" ...\n $ Width            : chr [1:125] \"70\" \"60\" \"75\" \"82\" ...\n $ Hight            : num [1:125] NA 30 60 60 30 35 13 29 15 60 ...\n $ Pit              : chr [1:125] \"P9\" \"P051\" \"P051\" \"P050\" ...\n $ sampled          : chr [1:125] NA \"Y\" \"Y\" NA ...\n $ start_layer      : num [1:125] 5 14 12 7 2 7 4 8 5 6 ...\n $ start_depth      : num [1:125] -70 -20 14 -25 -30 -30 -52 -30 -75 4 ...\n $ end_depth        : num [1:125] NA -50 -46 -85 -60 -65 -65 -59 -90 -56 ...\n $ start_depth_sure : chr [1:125] NA NA \"Y\" \"Y\" ...\n $ old_layer        : num [1:125] NA 3 4 4 4 4 4 4 4 4 ...\n $ Phase            : chr [1:125] \"pre\" \"euro\" \"post\" \"euro\" ...\n $ Coffin           : num [1:125] 1 NA 1 1 1 1 1 1 1 1 ...\n $ Straw_mat        : num [1:125] 0 0 1 0 0 0 0 1 0 0 ...\n $ Gender           : num [1:125] NA NA NA NA 3 NA NA 1 NA NA ...\n $ Age              : chr [1:125] NA \"4\" \"2\" NA ...\n $ Agate_bead       : num [1:125] NA NA NA NA NA NA NA NA 8 NA ...\n $ Golden_bead      : num [1:125] NA NA NA 5 2 2 NA 2 NA 2 ...\n $ Glass_bead       : chr [1:125] NA NA NA NA ...\n $ Indo-Pacific_bead: chr [1:125] NA NA NA NA ...\n $ Glass_earring    : num [1:125] NA NA NA NA NA NA NA NA NA NA ...\n $ Big_Metal_ring   : num [1:125] 2 NA NA 2 NA 2 NA NA 2 NA ...\n $ Small_Metal_ring : num [1:125] 1 NA NA 2 NA NA 2 NA NA NA ...\n $ Wide_Metal_ring  : num [1:125] NA NA NA NA NA NA NA NA NA NA ...\n $ Metal_ring       : num [1:125] NA NA NA NA NA NA NA NA NA 3 ...\n $ Bell             : num [1:125] NA NA NA NA NA 1 NA NA NA NA ...\n $ Knit             : logi [1:125] NA NA NA NA NA NA ...\n $ fish_shape_knit  : num [1:125] NA NA NA 1 NA NA NA NA NA NA ...\n $ Metal_string     : num [1:125] NA NA NA NA NA 1 NA NA NA 1 ...\n $ Metal_piece      : num [1:125] NA NA NA NA NA NA NA NA NA NA ...\n $ Metal_plate      : num [1:125] NA NA NA NA NA NA NA NA NA NA ...\n $ Hair_pin         : num [1:125] NA NA NA NA NA NA NA NA NA NA ...\n $ Niddle           : num [1:125] NA NA NA NA NA NA NA NA NA NA ...\n $ Bone_plate       : num [1:125] NA NA NA NA NA NA NA NA NA NA ...\n $ Comb             : num [1:125] 1 NA NA NA NA NA NA NA NA NA ...\n $ Coin             : num [1:125] NA NA NA NA NA NA NA NA NA NA ...\n $ Porcelain_bowl   : num [1:125] NA NA NA NA NA NA NA NA NA NA ...\n $ Porcelain_vessel : num [1:125] NA NA NA NA NA NA NA NA NA NA ...\n $ Porcelain_vase   : num [1:125] NA NA NA NA NA NA NA NA NA NA ...\n $ Blue_glazed_vase : num [1:125] NA NA NA NA NA NA NA NA NA NA ...\n $ Brown_glazed_vase: num [1:125] NA NA NA NA NA NA NA NA NA NA ...\n $ Porcelain_piece  : num [1:125] NA NA NA NA NA NA NA NA NA NA ...\n $ Ceramic_vase     : num [1:125] NA NA NA NA NA NA NA NA NA NA ...\n $ Iron_artifact    : num [1:125] NA NA NA NA NA NA NA NA NA NA ...\n $ Stone_artifact   : num [1:125] NA NA NA NA NA NA NA NA NA NA ...\n $ Grinding_stone   : num [1:125] NA NA NA NA NA NA NA NA NA NA ...\n $ Stone_hammer     : num [1:125] NA NA NA NA NA NA NA NA NA NA ...\n $ Stone_axe        : num [1:125] NA NA NA NA NA NA NA NA NA NA ...\n $ Wood_artifact    : num [1:125] NA NA NA NA NA NA NA NA NA NA ...\n $ Anping_jar       : num [1:125] NA NA NA NA NA NA NA NA NA NA ...\n $ Kendi_mouth      : num [1:125] NA NA NA NA NA NA NA NA NA NA ...\n\n\n\n\n\n\n\n\nOther useful functions\n\n\n\nSome useful functions to get a quick look at the data are:\n\nview() view the whole dataset (opens new tab)\nhead() see the first 6 rows\ntail() see the last 6 rows\nstr() see the structure of the data\nnames() see the column names\ndim() get the dimensions of the data (row number and column number)\nnrow() get the number of rows\nncol() get the number of columns\n\n\n\nIt looks like there are a couple of variables that should be numeric (num) are actually character (chr). We also have the typo we found before, Hight and a violation of the R naming rules, Indo-Pacific_bead.",
    "crumbs": [
      "Materials",
      "04 - Cleaning Data"
    ]
  },
  {
    "objectID": "docs/04_cleaning-data.html#renaming-variables",
    "href": "docs/04_cleaning-data.html#renaming-variables",
    "title": "Cleaning data with tidyverse",
    "section": "Renaming variables",
    "text": "Renaming variables\nIt would be best to fix the variable names right away to prevent mistakes when using them in future operations where we will intuitively want to type Height.\nThere are certain rules for naming objects in R. Names should:\n\ncontain only alphanumeric characters, underscores, _, and decimal points, .\nstart with a letter\nnot interfere with other R objects (this will take some experience)\n\nAnd then there are further recommendations:\n\nuse nouns for objects\nuse verbs for functions\nkeep them short, but explanatory (e.g., mean_height, not x)\n\nSince Indo-Pacific_bead contains a hyphen, -, whenever we want to use the variable we would have to wrap it in backticks, ```. This is true for all variables containing special characters. To fix this we canrenamethe variables. Therename()function syntax isrename(data,  = )`.\n\nrenamed_data &lt;- raw_data |&gt;\n  rename(\n    Height = Hight,\n    IndoPacific_bead = `Indo-Pacific_bead`,\n  )",
    "crumbs": [
      "Materials",
      "04 - Cleaning Data"
    ]
  },
  {
    "objectID": "docs/04_cleaning-data.html#data-types",
    "href": "docs/04_cleaning-data.html#data-types",
    "title": "Cleaning data with tidyverse",
    "section": "Data types",
    "text": "Data types\nSome variables that we might expect to be numeric, are coming up as character. We can take a closer look at the values by indexing the column with the dollar symbol, $:\n\nraw_data$Length\n\n  [1] \"115\" \"102\" \"104\" \"130\" \"140\" \"70\"  \"85+\" \"130\" \"100\" \"130\" \"90+\" NA   \n [13] \"95\"  \"76\"  \"100\" \"110\" NA    \"123\" \"105\" \"114\" \"105\" \"120\" \"95\"  \"100\"\n [25] \"115\" \"105\" \"75\"  \"135\" \"113\" \"140\" \"73\"  \"102\" \"110\" \"113\" \"205\" \"65\" \n [37] \"100\" \"125\" \"65\"  \"120\" \"88\"  \"90\"  \"90\"  \"125\" NA    \"70\"  \"105\" \"80\" \n [49] \"100\" \"122\" NA    \"85\"  \"53\"  \"90\"  \"60\"  \"55\"  \"90\"  \"70\"  \"90\"  \"65\" \n [61] \"90\"  \"75\"  \"100\" \"70\"  \"126\" \"120\" NA    \"128\" \"105\" \"120\" \"85\"  \"66\" \n [73] \"90\"  \"75\"  \"90\"  \"140\" NA    \"85\"  \"110\" \"80\"  \"100\" \"115\" \"75\"  NA   \n [85] NA    NA    \"93\"  \"105\" \"135\" \"90\"  \"90\"  NA    \"90\"  \"105\" \"100\" \"88\" \n [97] \"100\" \"95\"  NA    \"110\" \"100\" \"115\" \"85\"  \"120\" \"75\"  \"75\"  \"57+\" \"110\"\n[109] \"50\"  \"30\"  \"70\"  \"50\"  \"70\"  \"84\"  \"90\"  \"65\"  \"130\" \"65\"  NA    NA   \n[121] \"60\"  \"45\"  \"135\" \"60\"  \"155\"\n\nraw_data$Age\n\n  [1] NA       \"4\"      \"2\"      NA       \"4\"      \"2\"      NA       \"7\"     \n  [9] NA       \"7\"      NA       NA       NA       \"1\"      \"6\"      \"4\"     \n [17] NA       \"7\"      \"7\"      NA       NA       \"5\"      \"5\"      NA      \n [25] \"8\"      NA       NA       \"7\"      NA       \"3\"      \"2\"      NA      \n [33] NA       \"7\"      \"7\"      NA       NA       NA       NA       \"4\"     \n [41] NA       \"8\"      \"7\"      \"3 or 4\" NA       NA       NA       NA      \n [49] \"4\"      \"7\"      NA       NA       NA       \"2\"      \"2\"      \"2\"     \n [57] \"5\"      NA       NA       NA       NA       \"2\"      \"7\"      \"1\"     \n [65] \"5\"      \"6\"      NA       \"7\"      \"7\"      \"7\"      NA       \"2\"     \n [73] \"2\"      \"2\"      \"2\"      NA       NA       \"4\"      \"4\"      NA      \n [81] \"3\"      \"7\"      NA       \"7\"      \"7\"      \"7\"      NA       NA      \n [89] \"7\"      \"4\"      \"4\"      NA       \"2\"      \"5\"      \"4\"      \"4\"     \n [97] \"2\"      NA       NA       \"7\"      \"5\"      \"5\"      NA       \"5\"     \n[105] NA       NA       \"2\"      NA       NA       NA       \"7\"      NA      \n[113] NA       NA       NA       NA       NA       NA       NA       NA      \n[121] NA       NA       NA       NA       NA      \n\nraw_data$`Indo-Pacific_bead`\n\n  [1] NA              NA              NA              NA             \n  [5] NA              \"1\"             NA              NA             \n  [9] \"6\"             \"1526\"          \"18\"            NA             \n [13] NA              \"1\"             \"1\"             NA             \n [17] NA              \"2936\"          \"116\"           NA             \n [21] \"2\"             \"6\"             \"3\"             NA             \n [25] \"17\"            \"1\"             \"197\"           NA             \n [29] NA              NA              \"1\"             NA             \n [33] NA              \"4\"             \"6\"             NA             \n [37] \"60\"            NA              \"cluster\"       NA             \n [41] \"290\"           NA              \"19\"            NA             \n [45] NA              NA              \"5\"             NA             \n [49] NA              NA              \"1\"             NA             \n [53] NA              NA              NA              NA             \n [57] \"6\"             NA              NA              NA             \n [61] NA              \"2\"             NA              NA             \n [65] NA              NA              NA              NA             \n [69] \"12\"            NA              \"unsure number\" NA             \n [73] NA              NA              NA              \"4\"            \n [77] NA              NA              \"9\"             \"3\"            \n [81] NA              NA              NA              NA             \n [85] NA              NA              NA              \"1\"            \n [89] \"999\"           NA              NA              NA             \n [93] NA              NA              \"6\"             NA             \n [97] NA              NA              NA              \"13\"           \n[101] \"1\"             NA              NA              NA             \n[105] NA              \"1\"             NA              \"1\"            \n[109] NA              NA              NA              NA             \n[113] NA              NA              NA              NA             \n[117] \"1\"             NA              NA              \"1\"            \n[121] NA              NA              NA              NA             \n[125] NA             \n\n\nIt‚Äôs also possible to index a column using the name of the column,\n\nraw_data[\"Length\"]\n\n# A tibble: 125 √ó 1\n   Length\n   &lt;chr&gt; \n 1 115   \n 2 102   \n 3 104   \n 4 130   \n 5 140   \n 6 70    \n 7 85+   \n 8 130   \n 9 100   \n10 130   \n# ‚Ñπ 115 more rows\n\n\nor the position. Because a data frame is two-dimensional, the position needs two values, the row number(s) and column number(s), respectively. To index all rows, leave it blank.\n\nraw_data[,6] # all rows, column 6\n\n# A tibble: 125 √ó 1\n   Length\n   &lt;chr&gt; \n 1 115   \n 2 102   \n 3 104   \n 4 130   \n 5 140   \n 6 70    \n 7 85+   \n 8 130   \n 9 100   \n10 130   \n# ‚Ñπ 115 more rows\n\n\n\n\n\n\n\n\nNote\n\n\n\nAs you may have noticed, indexing with $ produces a vector, and [\"name\"] and [row,col] produce a tibble/data frame.\nTo extract a column as a vector using name and position, use double brackets: [[\"name\"]] and [[col]].\n\n\nIt looks like some characters were used in the columns, which means that the columns could not be imported as numeric. This is because R can only have one type in a column. For example, there is a value in Glass_bead called ‚Äòshatter‚Äô. Since a vector, or column in a data frame, can only contain one type, R imported the many of our columns as character.\nThere are three main classes of values that we are going to use.\n\n\n\n\n\n\n\nClass\nDescription\n\n\n\n\ncharacter\nStrings of any kind (‚Äúword‚Äù, ‚Äúmultiple words‚Äù, ‚Äújka9qy0‚Äù)\n\n\nlogical\nBoolean type (TRUE, FALSE) and NA\n\n\nnumeric\nNumeric values (1, 2, 3.4, etc.)\n\n\n\n\n\n\n\n\n\nExercise\n\n\n\nCreate the following vectors\n\nnum_char &lt;- c(1, 2, 3, \"a\")\nnum_logical &lt;- c(1, 2, 3, TRUE)\nchar_logical &lt;- c(\"a\", \"b\", \"c\", TRUE)\ntricky &lt;- c(1, 2, 3, \"4\")\n\nand see what typeof object they are or what class they are, and see if you can figure out why they are what they are.\n\n\n\n\n\n\nSolution\n\n\n\n\n\n\ntypeof(num_char)\n\n[1] \"character\"\n\ntypeof(num_logical)\n\n[1] \"double\"\n\ntypeof(char_logical)\n\n[1] \"character\"\n\ntypeof(tricky)\n\n[1] \"character\"\n\n\nThe conversion sequence in R is character &lt; double &lt; integer &lt; logical.\nLogical can be converted to numeric (TRUE becomes 1, and FALSE becomes 0), and numeric can be converted to a string (3 becomes ‚Äú3‚Äù), but a string cannot be converted to numeric or logical (what would ‚Äúglass‚Äù be as a number?). Number strings, e.g., ‚Äú3‚Äù, can be converted back to a numeric.\n\nas.numeric(c(\"1\", \"2\", \"3\"))\n\n[1] 1 2 3\n\n\nBut any non-numbers will be replaced with NA. Luckily R warns you about this.\n\nas.numeric(c(\"1\", \"2\", \"three\"))\n\nWarning: NAs introduced by coercion\n\n\n[1]  1  2 NA",
    "crumbs": [
      "Materials",
      "04 - Cleaning Data"
    ]
  },
  {
    "objectID": "docs/04_cleaning-data.html#modifying-variables-with-mutate",
    "href": "docs/04_cleaning-data.html#modifying-variables-with-mutate",
    "title": "Cleaning data with tidyverse",
    "section": "Modifying variables with mutate()",
    "text": "Modifying variables with mutate()\nWe need to modify the Glass_bead variable to numeric. That means we need to decide what to do with ‚Äòshatter‚Äô. We could change it to NA, or assume that it represents at least one, and change it to 1. We can do this with the mutate() and if_else() functions.\n\n\n\nAllison Horst\n\n\nmutate requires a data frame as the first argument (.data) and then name-value pairs, where the name will be the new column name and the value the new value(s) of the column.\nmutate(data, new_column = new_value)\nInstead of a single value we can use a function or equation to calculate a new variable. And instead of creating a new variable, we can provide the name of an existing column instead of using a new name. There are a few common issues with multiple variables that we can fix.\nFor example, to modify the Glass_bead variable, we can combine mutate and if_else functions to determine what the new values should be based on whether a value matches a certain condition.\n\nmutate(\n  renamed_data,                          # the data\n  Glass_bead = if_else(                  # the new/existing variable and function\n    condition = Glass_bead == \"shatter\", # the condition\n    true = NA,                           # the new value for matches\n    false = Glass_bead                   # the new value for non-matches\n  )\n) \n\n# A tibble: 125 √ó 55\n   Layer ID    Burial_axis Degree_axis Condition Length Width Height Pit  \n   &lt;dbl&gt; &lt;chr&gt;       &lt;dbl&gt;       &lt;dbl&gt;     &lt;dbl&gt; &lt;chr&gt;  &lt;chr&gt;  &lt;dbl&gt; &lt;chr&gt;\n 1     1 0               1         290         3 115    70        NA P9   \n 2     1 1               1         295         2 102    60        30 P051 \n 3     1 2               1         290         2 104    75        60 P051 \n 4     1 3               1         290         1 130    82        60 P050 \n 5     1 4               1         300         2 140    73        30 P038 \n 6     1 5               1         285         2 70     50        35 P050 \n 7     1 6               1         310         3 85+    55        13 P038 \n 8     1 7               1         290         2 130    60        29 P028 \n 9     1 8               1         295         2 100    58        15 P038 \n10     1 9               1         300         1 130    70        60 P052 \n# ‚Ñπ 115 more rows\n# ‚Ñπ 46 more variables: sampled &lt;chr&gt;, start_layer &lt;dbl&gt;, start_depth &lt;dbl&gt;,\n#   end_depth &lt;dbl&gt;, start_depth_sure &lt;chr&gt;, old_layer &lt;dbl&gt;, Phase &lt;chr&gt;,\n#   Coffin &lt;dbl&gt;, Straw_mat &lt;dbl&gt;, Gender &lt;dbl&gt;, Age &lt;chr&gt;, Agate_bead &lt;dbl&gt;,\n#   Golden_bead &lt;dbl&gt;, Glass_bead &lt;chr&gt;, IndoPacific_bead &lt;chr&gt;,\n#   Glass_earring &lt;dbl&gt;, Big_Metal_ring &lt;dbl&gt;, Small_Metal_ring &lt;dbl&gt;,\n#   Wide_Metal_ring &lt;dbl&gt;, Metal_ring &lt;dbl&gt;, Bell &lt;dbl&gt;, Knit &lt;lgl&gt;, ‚Ä¶\n\n\nif_else() requires three main arguments: (1) the condition to evaluate, (2) the new value for all the values that match the condition, and (3) the new value for all the values that don‚Äôt match the condition. The condition therefore needs to produce a Boolean vector. In our case this is produced by Glass_bead == \"shatter\", which we can check by running\n\nrenamed_data$Glass_bead == \"shatter\"\n\n  [1]    NA    NA    NA    NA    NA    NA FALSE FALSE    NA    NA    NA    NA\n [13]    NA    NA    NA    NA    NA    NA    NA    NA    NA    NA    NA    NA\n [25]    NA    NA FALSE    NA    NA    NA    NA    NA    NA    NA    NA    NA\n [37]    NA    NA    NA    NA    NA    NA    NA    NA    NA    NA    NA    NA\n [49]    NA    NA    NA    NA    NA    NA    NA    NA    NA    NA    NA    NA\n [61]    NA    NA    NA    NA    NA    NA    NA    NA    NA    NA  TRUE    NA\n [73]    NA    NA    NA    NA    NA    NA    NA    NA    NA    NA    NA    NA\n [85]    NA    NA    NA    NA    NA    NA    NA    NA    NA    NA    NA    NA\n [97]    NA    NA    NA    NA    NA    NA    NA    NA    NA    NA    NA    NA\n[109]    NA    NA    NA    NA    NA    NA    NA    NA    NA    NA    NA    NA\n[121]    NA    NA    NA    NA    NA\n\n\nIn each instance where the value is TRUE, the value is changed to NA (true = NA) and in each instance where the value is FALSE, it stays the same as the original variable (false = Glass_bead).\nWe can also use this Boolean vector to index our Glass_bead column.\n\nrenamed_data$Glass_bead[renamed_data$Glass_bead == \"shatter\"]\n\n  [1] NA        NA        NA        NA        NA        NA        NA       \n  [8] NA        NA        NA        NA        NA        NA        NA       \n [15] NA        NA        NA        NA        NA        NA        NA       \n [22] NA        NA        NA        NA        NA        NA        NA       \n [29] NA        NA        NA        NA        NA        NA        NA       \n [36] NA        NA        NA        NA        NA        NA        NA       \n [43] NA        NA        NA        NA        NA        NA        NA       \n [50] NA        NA        NA        NA        NA        NA        NA       \n [57] NA        NA        NA        NA        NA        NA        NA       \n [64] NA        NA        NA        NA        \"shatter\" NA        NA       \n [71] NA        NA        NA        NA        NA        NA        NA       \n [78] NA        NA        NA        NA        NA        NA        NA       \n [85] NA        NA        NA        NA        NA        NA        NA       \n [92] NA        NA        NA        NA        NA        NA        NA       \n [99] NA        NA        NA        NA        NA        NA        NA       \n[106] NA        NA        NA        NA        NA        NA        NA       \n[113] NA        NA        NA        NA        NA        NA        NA       \n[120] NA        NA        NA       \n\n\nReading from the inside out, the code within the square brackets produces a Boolean vector where all entries with ‚Äòshatter‚Äô are TRUE and all other values are FALSE. When you use a Boolean vector to index another vector, it will ‚Äòshow‚Äô all values that are TRUE and remove all values that coincide with a FALSE value.\nWe can then modify the variable by assigning a new value to the indexed values.\n\nrenamed_data$Glass_bead[renamed_data$Glass_bead == \"shatter\"] &lt;- NA\n\nWhich produces the same outcome as the if_else() and mutate() functions.\nThis also means that if_else() is limited to a single condition producing two new values. It wouldn‚Äôt work to fix IndoPacific_bead. At least not without introducing additional functions and some unnecessary code gymnastics (which I‚Äôm avoiding to keep the examples somewhat simple).\ncase_when() allows us to introduce multiple conditions, and works in a similar way to if_else(). It takes a condition on the left-hand side (LHS), and a value on the right-hand side (RHS), and a .default value for any values that don‚Äôt satisfy any of the provided conditions.\ncase_when(condition ~ value, .default = value)\n\nmutate(\n  renamed_data,\n  IndoPacicific_bead = case_when(\n    IndoPacific_bead == \"cluster\" ~ NA,       # first condition, LHS ~ RHS\n    IndoPacific_bead == \"unsure number\" ~ NA, # second condition, LHS ~ RHS\n    .default = IndoPacific_bead               # for non-matches\n  ) \n)\n\n# A tibble: 125 √ó 56\n   Layer ID    Burial_axis Degree_axis Condition Length Width Height Pit  \n   &lt;dbl&gt; &lt;chr&gt;       &lt;dbl&gt;       &lt;dbl&gt;     &lt;dbl&gt; &lt;chr&gt;  &lt;chr&gt;  &lt;dbl&gt; &lt;chr&gt;\n 1     1 0               1         290         3 115    70        NA P9   \n 2     1 1               1         295         2 102    60        30 P051 \n 3     1 2               1         290         2 104    75        60 P051 \n 4     1 3               1         290         1 130    82        60 P050 \n 5     1 4               1         300         2 140    73        30 P038 \n 6     1 5               1         285         2 70     50        35 P050 \n 7     1 6               1         310         3 85+    55        13 P038 \n 8     1 7               1         290         2 130    60        29 P028 \n 9     1 8               1         295         2 100    58        15 P038 \n10     1 9               1         300         1 130    70        60 P052 \n# ‚Ñπ 115 more rows\n# ‚Ñπ 47 more variables: sampled &lt;chr&gt;, start_layer &lt;dbl&gt;, start_depth &lt;dbl&gt;,\n#   end_depth &lt;dbl&gt;, start_depth_sure &lt;chr&gt;, old_layer &lt;dbl&gt;, Phase &lt;chr&gt;,\n#   Coffin &lt;dbl&gt;, Straw_mat &lt;dbl&gt;, Gender &lt;dbl&gt;, Age &lt;chr&gt;, Agate_bead &lt;dbl&gt;,\n#   Golden_bead &lt;dbl&gt;, Glass_bead &lt;chr&gt;, IndoPacific_bead &lt;chr&gt;,\n#   Glass_earring &lt;dbl&gt;, Big_Metal_ring &lt;dbl&gt;, Small_Metal_ring &lt;dbl&gt;,\n#   Wide_Metal_ring &lt;dbl&gt;, Metal_ring &lt;dbl&gt;, Bell &lt;dbl&gt;, Knit &lt;lgl&gt;, ‚Ä¶",
    "crumbs": [
      "Materials",
      "04 - Cleaning Data"
    ]
  },
  {
    "objectID": "docs/04_cleaning-data.html#modifying-strings-with-stringr",
    "href": "docs/04_cleaning-data.html#modifying-strings-with-stringr",
    "title": "Cleaning data with tidyverse",
    "section": "Modifying strings with stringr",
    "text": "Modifying strings with stringr\nNext on our cleaning list are Width and Length. These were imported as character because of the plus symbol (+) in some of the variables, presumably indicating a measurement ‚Äòor greater‚Äô. To fix this, we will just remove the symbol and keep the value (nevermind if this might not be ideal from an analytical perspective‚Ä¶).\nWe will use the stringr package to work with characters, which, conveniently is also part of tidyverse (it‚Äôs like they know what functionality we need to clean our data‚Ä¶) Since we‚Äôre interested in removing a character, we can use the str_remove() function, which takes a character vector as the first, and a pattern as the second argument.\n\nstr_remove(renamed_data$Width, \"\\\\+\")\n\n  [1] \"70\" \"60\" \"75\" \"82\" \"73\" \"50\" \"55\" \"60\" \"58\" \"70\" \"60\" NA   \"60\" \"45\" \"60\"\n [16] \"70\" NA   \"60\" \"47\" \"70\" \"55\" \"70\" \"45\" \"70\" \"80\" \"45\" \"75\" \"70\" \"73\" \"58\"\n [31] \"45\" \"60\" \"45\" \"60\" \"57\" \"45\" \"55\" \"65\" \"45\" \"75\" \"50\" \"50\" \"50\" \"70\" NA  \n [46] \"70\" \"75\" \"60\" \"70\" \"56\" NA   \"70\" \"53\" \"56\" \"35\" \"40\" \"60\" \"70\" \"90\" \"40\"\n [61] \"65\" \"65\" \"55\" \"45\" \"65\" \"60\" NA   \"60\" \"65\" \"70\" \"75\" \"40\" \"60\" \"40\" \"45\"\n [76] \"70\" NA   \"65\" \"55\" \"50\" \"60\" \"70\" \"45\" NA   NA   NA   \"83\" \"60\" \"60\" \"50\"\n [91] \"65\" NA   \"50\" \"60\" \"70\" \"85\" \"55\" \"70\" NA   \"60\" \"53\" \"60\" \"55\" \"70\" \"47\"\n[106] \"60\" \"40\" \"55\" \"40\" \"20\" \"50\" \"25\" \"46\" \"78\" \"55\" \"55\" \"60\" \"45\" NA   NA  \n[121] \"60\" \"35\" \"75\" \"60\" \"40\"\n\n\n\n\n\n\n\n\nRegular expressions (Regex)\n\n\n\nThe default interpretation of the pattern argument is a regular expression. Because + is a special character in regex, we need to ‚Äòescape‚Äô it, so str_remove only interprets it as a plus symbol, and not its additional regex functionality. We can ‚Äòescape‚Äô symbols by prefixing them with \\\\.\nAn alternative would have been to use str_remove(renamed_data$Width, fixed(\"+\")), which compares literal bytes instead of interpreting regex.\nSee vignette(\"regular-expressions\") for more details.\n\n\nWe can incorporate this function into mutate().\n\nmutate(renamed_data, Width = str_remove(Width, \"\\\\+\"))$Width\n\n  [1] \"70\" \"60\" \"75\" \"82\" \"73\" \"50\" \"55\" \"60\" \"58\" \"70\" \"60\" NA   \"60\" \"45\" \"60\"\n [16] \"70\" NA   \"60\" \"47\" \"70\" \"55\" \"70\" \"45\" \"70\" \"80\" \"45\" \"75\" \"70\" \"73\" \"58\"\n [31] \"45\" \"60\" \"45\" \"60\" \"57\" \"45\" \"55\" \"65\" \"45\" \"75\" \"50\" \"50\" \"50\" \"70\" NA  \n [46] \"70\" \"75\" \"60\" \"70\" \"56\" NA   \"70\" \"53\" \"56\" \"35\" \"40\" \"60\" \"70\" \"90\" \"40\"\n [61] \"65\" \"65\" \"55\" \"45\" \"65\" \"60\" NA   \"60\" \"65\" \"70\" \"75\" \"40\" \"60\" \"40\" \"45\"\n [76] \"70\" NA   \"65\" \"55\" \"50\" \"60\" \"70\" \"45\" NA   NA   NA   \"83\" \"60\" \"60\" \"50\"\n [91] \"65\" NA   \"50\" \"60\" \"70\" \"85\" \"55\" \"70\" NA   \"60\" \"53\" \"60\" \"55\" \"70\" \"47\"\n[106] \"60\" \"40\" \"55\" \"40\" \"20\" \"50\" \"25\" \"46\" \"78\" \"55\" \"55\" \"60\" \"45\" NA   NA  \n[121] \"60\" \"35\" \"75\" \"60\" \"40\"\n\n# no need to subset Width from the data frame within str_remove()\n\nThe Length variable requires exactly the same fix, so we can just repeat the same code with the Length variable.\n\nmutate(\n  renamed_data,\n  Width = str_remove(Width, \"\\\\+\"),\n  Length = str_remove(Length, \"\\\\+\")\n)\n\n# A tibble: 125 √ó 55\n   Layer ID    Burial_axis Degree_axis Condition Length Width Height Pit  \n   &lt;dbl&gt; &lt;chr&gt;       &lt;dbl&gt;       &lt;dbl&gt;     &lt;dbl&gt; &lt;chr&gt;  &lt;chr&gt;  &lt;dbl&gt; &lt;chr&gt;\n 1     1 0               1         290         3 115    70        NA P9   \n 2     1 1               1         295         2 102    60        30 P051 \n 3     1 2               1         290         2 104    75        60 P051 \n 4     1 3               1         290         1 130    82        60 P050 \n 5     1 4               1         300         2 140    73        30 P038 \n 6     1 5               1         285         2 70     50        35 P050 \n 7     1 6               1         310         3 85     55        13 P038 \n 8     1 7               1         290         2 130    60        29 P028 \n 9     1 8               1         295         2 100    58        15 P038 \n10     1 9               1         300         1 130    70        60 P052 \n# ‚Ñπ 115 more rows\n# ‚Ñπ 46 more variables: sampled &lt;chr&gt;, start_layer &lt;dbl&gt;, start_depth &lt;dbl&gt;,\n#   end_depth &lt;dbl&gt;, start_depth_sure &lt;chr&gt;, old_layer &lt;dbl&gt;, Phase &lt;chr&gt;,\n#   Coffin &lt;dbl&gt;, Straw_mat &lt;dbl&gt;, Gender &lt;dbl&gt;, Age &lt;chr&gt;, Agate_bead &lt;dbl&gt;,\n#   Golden_bead &lt;dbl&gt;, Glass_bead &lt;chr&gt;, IndoPacific_bead &lt;chr&gt;,\n#   Glass_earring &lt;dbl&gt;, Big_Metal_ring &lt;dbl&gt;, Small_Metal_ring &lt;dbl&gt;,\n#   Wide_Metal_ring &lt;dbl&gt;, Metal_ring &lt;dbl&gt;, Bell &lt;dbl&gt;, Knit &lt;lgl&gt;, ‚Ä¶\n\n\nPerforming our cleaning operations with the pipe looks like this:\n\nraw_data |&gt; # take our raw data, and then...\n  rename(\n    Height = Hight,\n    IndoPacific_bead = `Indo-Pacific_bead`\n  ) |&gt; # rename variables, and then...\n  mutate(\n    Glass_bead = if_else( \n      condition = Glass_bead == \"shatter\",\n      true = NA,\n      false = Glass_bead\n    )\n   ) |&gt; # mutate Glass_bead, and then...\n  mutate(\n    IndoPacific_bead = case_when(\n      IndoPacific_bead == \"cluster\" ~ NA,\n      IndoPacific_bead == \"unsure number\" ~ NA,\n      .default = IndoPacific_bead\n    )\n  ) |&gt; # mutate IndoPacific_bead, and then...\n  mutate(\n    Width = str_remove(Width, \"\\\\+\"),\n    Length = str_remove(Length, \"\\\\+\")\n  ) # mutate Width and Length\n\n# A tibble: 125 √ó 55\n   Layer ID    Burial_axis Degree_axis Condition Length Width Height Pit  \n   &lt;dbl&gt; &lt;chr&gt;       &lt;dbl&gt;       &lt;dbl&gt;     &lt;dbl&gt; &lt;chr&gt;  &lt;chr&gt;  &lt;dbl&gt; &lt;chr&gt;\n 1     1 0               1         290         3 115    70        NA P9   \n 2     1 1               1         295         2 102    60        30 P051 \n 3     1 2               1         290         2 104    75        60 P051 \n 4     1 3               1         290         1 130    82        60 P050 \n 5     1 4               1         300         2 140    73        30 P038 \n 6     1 5               1         285         2 70     50        35 P050 \n 7     1 6               1         310         3 85     55        13 P038 \n 8     1 7               1         290         2 130    60        29 P028 \n 9     1 8               1         295         2 100    58        15 P038 \n10     1 9               1         300         1 130    70        60 P052 \n# ‚Ñπ 115 more rows\n# ‚Ñπ 46 more variables: sampled &lt;chr&gt;, start_layer &lt;dbl&gt;, start_depth &lt;dbl&gt;,\n#   end_depth &lt;dbl&gt;, start_depth_sure &lt;chr&gt;, old_layer &lt;dbl&gt;, Phase &lt;chr&gt;,\n#   Coffin &lt;dbl&gt;, Straw_mat &lt;dbl&gt;, Gender &lt;dbl&gt;, Age &lt;chr&gt;, Agate_bead &lt;dbl&gt;,\n#   Golden_bead &lt;dbl&gt;, Glass_bead &lt;chr&gt;, IndoPacific_bead &lt;chr&gt;,\n#   Glass_earring &lt;dbl&gt;, Big_Metal_ring &lt;dbl&gt;, Small_Metal_ring &lt;dbl&gt;,\n#   Wide_Metal_ring &lt;dbl&gt;, Metal_ring &lt;dbl&gt;, Bell &lt;dbl&gt;, Knit &lt;lgl&gt;, ‚Ä¶\n\n\nSince all the steps use mutate() we don‚Äôt actually need the pipe. mutate can take multiple name-value pairs separated by a comma (,).\nmutate(\n  .data, \n  new_column = new_value, \n  another_new_column = another_new_value,\n  yet_another = new_value3\n)\n\nraw_data |&gt; # take our raw data, and then\n  rename(\n    Height = Hight,\n    IndoPacific_bead = `Indo-Pacific_bead`\n  ) |&gt;\n  mutate(\n    Glass_bead = if_else( # mutate Glass_bead\n      condition = Glass_bead == \"shatter\",\n      true = NA,\n      false = Glass_bead\n    ), # and then take the new data frame and pipe it to\n    IndoPacific_bead = case_when( # and Indo-Pacific_bead\n      IndoPacific_bead == \"cluster\" ~ NA,\n      IndoPacific_bead == \"unsure number\" ~ NA,\n      .default = IndoPacific_bead\n    ),\n    Width = str_remove(Width, \"\\\\+\"),\n    Length = str_remove(Length, \"\\\\+\")\n  )\n\n# A tibble: 125 √ó 55\n   Layer ID    Burial_axis Degree_axis Condition Length Width Height Pit  \n   &lt;dbl&gt; &lt;chr&gt;       &lt;dbl&gt;       &lt;dbl&gt;     &lt;dbl&gt; &lt;chr&gt;  &lt;chr&gt;  &lt;dbl&gt; &lt;chr&gt;\n 1     1 0               1         290         3 115    70        NA P9   \n 2     1 1               1         295         2 102    60        30 P051 \n 3     1 2               1         290         2 104    75        60 P051 \n 4     1 3               1         290         1 130    82        60 P050 \n 5     1 4               1         300         2 140    73        30 P038 \n 6     1 5               1         285         2 70     50        35 P050 \n 7     1 6               1         310         3 85     55        13 P038 \n 8     1 7               1         290         2 130    60        29 P028 \n 9     1 8               1         295         2 100    58        15 P038 \n10     1 9               1         300         1 130    70        60 P052 \n# ‚Ñπ 115 more rows\n# ‚Ñπ 46 more variables: sampled &lt;chr&gt;, start_layer &lt;dbl&gt;, start_depth &lt;dbl&gt;,\n#   end_depth &lt;dbl&gt;, start_depth_sure &lt;chr&gt;, old_layer &lt;dbl&gt;, Phase &lt;chr&gt;,\n#   Coffin &lt;dbl&gt;, Straw_mat &lt;dbl&gt;, Gender &lt;dbl&gt;, Age &lt;chr&gt;, Agate_bead &lt;dbl&gt;,\n#   Golden_bead &lt;dbl&gt;, Glass_bead &lt;chr&gt;, IndoPacific_bead &lt;chr&gt;,\n#   Glass_earring &lt;dbl&gt;, Big_Metal_ring &lt;dbl&gt;, Small_Metal_ring &lt;dbl&gt;,\n#   Wide_Metal_ring &lt;dbl&gt;, Metal_ring &lt;dbl&gt;, Bell &lt;dbl&gt;, Knit &lt;lgl&gt;, ‚Ä¶\n\n\nWhat you may have noticed is that the variables are still character vectors (indicated by the quotations marks, \"\" surrounding each value). What we have done in the above code is just remove all characters that could interfere with our conversion from character to numeric, but we still need to explicitly make the conversion using as.numeric(), a function that converts a value or a vector of values to numeric (assuming the values are all numbers or TRUE/FALSE).\nWe could wrap as.numeric() around each mutate operation we have performed,\ndata_clean &lt;- raw_data |&gt; # take our raw data, and then\n  rename(\n    Height = Hight,\n    IndoPacific_bead = `Indo-Pacific_bead`\n  ) |&gt;\n  mutate(\n    Glass_bead = is.numeric(if_else( # mutate Glass_bead\n      condition = Glass_bead == \"shatter\",\n      true = NA,\n      false = Glass_bead\n    )), # and then take the new data frame and pipe it to\n    IndoPacific_bead = is.numeric(case_when( # and Indo-Pacific_bead\n      IndoPacific_bead == \"cluster\" ~ NA,\n      IndoPacific_bead == \"unsure number\" ~ NA,\n      .default = IndoPacific_bead\n    ))\n  ) \n  ... etc.\nbut a more efficient option would be to do it all at once. Enter across().\n\nraw_data |&gt; # take our raw data, and then...\n  rename(\n    Height = Hight,\n    IndoPacific_bead = `Indo-Pacific_bead`\n  ) |&gt; # rename variables, and then...\n  mutate(\n    Glass_bead = if_else( \n      condition = Glass_bead == \"shatter\",\n      true = NA,\n      false = Glass_bead\n    )\n   ) |&gt; # mutate Glass_bead, and then...\n  mutate(\n    IndoPacific_bead = case_when(\n      IndoPacific_bead == \"cluster\" ~ NA,\n      IndoPacific_bead == \"unsure number\" ~ NA,\n      .default = IndoPacific_bead\n    )\n  ) |&gt; # mutate IndoPacific_bead, and then...\n  mutate(\n    Width = str_remove(Width, \"\\\\+\"),\n    Length = str_remove(Length, \"\\\\+\")\n  ) |&gt; # mutate Width and Length\n  mutate(\n    across(\n      .cols = c(Glass_bead, IndoPacific_bead, Width, Length),\n      .fns = as.numeric\n    )\n  )\n\n# A tibble: 125 √ó 55\n   Layer ID    Burial_axis Degree_axis Condition Length Width Height Pit  \n   &lt;dbl&gt; &lt;chr&gt;       &lt;dbl&gt;       &lt;dbl&gt;     &lt;dbl&gt;  &lt;dbl&gt; &lt;dbl&gt;  &lt;dbl&gt; &lt;chr&gt;\n 1     1 0               1         290         3    115    70     NA P9   \n 2     1 1               1         295         2    102    60     30 P051 \n 3     1 2               1         290         2    104    75     60 P051 \n 4     1 3               1         290         1    130    82     60 P050 \n 5     1 4               1         300         2    140    73     30 P038 \n 6     1 5               1         285         2     70    50     35 P050 \n 7     1 6               1         310         3     85    55     13 P038 \n 8     1 7               1         290         2    130    60     29 P028 \n 9     1 8               1         295         2    100    58     15 P038 \n10     1 9               1         300         1    130    70     60 P052 \n# ‚Ñπ 115 more rows\n# ‚Ñπ 46 more variables: sampled &lt;chr&gt;, start_layer &lt;dbl&gt;, start_depth &lt;dbl&gt;,\n#   end_depth &lt;dbl&gt;, start_depth_sure &lt;chr&gt;, old_layer &lt;dbl&gt;, Phase &lt;chr&gt;,\n#   Coffin &lt;dbl&gt;, Straw_mat &lt;dbl&gt;, Gender &lt;dbl&gt;, Age &lt;chr&gt;, Agate_bead &lt;dbl&gt;,\n#   Golden_bead &lt;dbl&gt;, Glass_bead &lt;dbl&gt;, IndoPacific_bead &lt;dbl&gt;,\n#   Glass_earring &lt;dbl&gt;, Big_Metal_ring &lt;dbl&gt;, Small_Metal_ring &lt;dbl&gt;,\n#   Wide_Metal_ring &lt;dbl&gt;, Metal_ring &lt;dbl&gt;, Bell &lt;dbl&gt;, Knit &lt;lgl&gt;, ‚Ä¶\n\n\nAcross allows us to apply the same function across multiple columns of our choosing. We specify the columns we want to mutate in the .cols argument (combining them with c()), then the function we want to apply with the .fns argument. across() will be revisited in 06 - Data Transformation.\n\n\n\n\n\n\nArgument names with . in tidyverse\n\n\n\n\n\nIn many tidyverse functions you will see argument names starting with a dot, ., for example .data and .cols.\nThis is because many tidyverse functions allow you to pass multiple variable names (like we did in mutate), which increases the risk that a variable name may conflict with an argument name (if the argument has the same name as a variable). By using a dot in front of the argument name, this reduces the risk of conflict (unless you really like putting dots at the start of your variable names - not recommended).\n\n\n\nNow we just need to store the output in an object; we‚Äôll call it data_clean\n\ndata_clean &lt;- raw_data |&gt; # take our raw data, and then...\n  rename(\n    Height = Hight,\n    IndoPacific_bead = `Indo-Pacific_bead`\n  ) |&gt; # rename variables, and then...\n  mutate(\n    Glass_bead = if_else( \n      condition = Glass_bead == \"shatter\",\n      true = NA,\n      false = Glass_bead\n    )\n   ) |&gt; # mutate Glass_bead, and then...\n  mutate(\n    IndoPacific_bead = case_when(\n      IndoPacific_bead == \"cluster\" ~ NA,\n      IndoPacific_bead == \"unsure number\" ~ NA,\n      .default = IndoPacific_bead\n    )\n  ) |&gt; # mutate IndoPacific_bead, and then...\n  mutate(\n    Width = str_remove(Width, \"\\\\+\"),\n    Length = str_remove(Length, \"\\\\+\")\n  ) |&gt; # mutate Width and Length\n  mutate(\n    across(\n      .cols = c(Glass_bead, IndoPacific_bead, Width, Length),\n      .fns = as.numeric\n    )\n  )\n\nand then try the plot again.\n\ndata_clean |&gt;\n  ggplot(aes(x = Width, y = Height, col = Phase)) +\n    geom_point()\n\nWarning: Removed 14 rows containing missing values or values outside the scale range\n(`geom_point()`).\n\n\n\n\n\n\n\n\n\nSuccess!",
    "crumbs": [
      "Materials",
      "04 - Cleaning Data"
    ]
  },
  {
    "objectID": "docs/04_cleaning-data.html#exporting-data",
    "href": "docs/04_cleaning-data.html#exporting-data",
    "title": "Cleaning data with tidyverse",
    "section": "Exporting data",
    "text": "Exporting data\nNow that we have cleaned data it would be nice to save it, so we don‚Äôt have to go through the cleaning steps every time we want to use the data. We will be exporting to a .csv file, since this format is more interoperable than .xlsx.\nWe will use write_csv() from the readr package, which, you guessed it, is part of tidyverse. We will store the new file in the data/ folder.\n\nwrite_csv(data_clean, here(\"data/mortuary_clean.csv\"))",
    "crumbs": [
      "Materials",
      "04 - Cleaning Data"
    ]
  },
  {
    "objectID": "docs/04_cleaning-data.html#finishing-up",
    "href": "docs/04_cleaning-data.html#finishing-up",
    "title": "Cleaning data with tidyverse",
    "section": "Finishing up",
    "text": "Finishing up\nA note on reproducibility. We have a lot of objects in the Global Environment (see the Environment pane), and these will not be present in someone else‚Äôs Global Environment unless they are produced using the script. So a good test to see if the script runs as it should from a clean Environment is to clear our environment with rm(list = ls()), and then run the script.\n\n\n\n\n\n\nDon‚Äôt be rude\n\n\n\nIt‚Äôs important when you are sharing code that your code is not invasive. rm(list = ls()) is very invasive code because it clears the Global Environment of the user.\nDo not include rm(list = ls()) in a script that you are sharing with others (just don‚Äôt include it in a script. Period.) Or any other invasive code that modifies the users environment. Otherwise Jenny Bryan will set your computer on fire.\n\n\n\nAnother recommendation was also discussed in 03 - RStudio Projects: to ensure reproducibility do not to save your workspace when you close RStudio (the default behaviour). To change the default setting, go to\nTools &gt; Global Options‚Ä¶ &gt; Workspace\nAnd make sure the option ‚ÄòRestore .RData into workspace at startup‚Äô is not selected, and that ‚ÄòSave workspace to .RData on exit‚Äô is set to ‚ÄòNever‚Äô.",
    "crumbs": [
      "Materials",
      "04 - Cleaning Data"
    ]
  },
  {
    "objectID": "assignments.html",
    "href": "assignments.html",
    "title": "Assignments",
    "section": "",
    "text": "Assignment 1 consists of finding, importing, cleaning, and exploring/analysing a dataset.\n\n\nFind a dataset that you want to work with, then use a script to download and clean the data.\nIf you can‚Äôt find a dataset, you can use the full, unmodified version of the workshop data here: https://osf.io/zem9p\n\n\n\nIf the EDA module is included in the workshop, then assignment 1 is extended to include EDA. Plot the distribution of at least two types of variables that you are interested in exploring further.\nCreate at least one plot with the relationship between two variables, and a summary table with the mean and standard deviation within groupings of a variable. \n\n\n\nIf the data modelling module is taught in the workshop, select at least two statistical models to apply to the data.\n\n\n\nUse Quarto to communicate the results from the previous sections of assignment 1. This can be in the form of a report, short manuscript, presentation, or whatever format in Quarto you prefer.",
    "crumbs": [
      "Assignments"
    ]
  },
  {
    "objectID": "assignments.html#assignment-1-case-study",
    "href": "assignments.html#assignment-1-case-study",
    "title": "Assignments",
    "section": "",
    "text": "Assignment 1 consists of finding, importing, cleaning, and exploring/analysing a dataset.\n\n\nFind a dataset that you want to work with, then use a script to download and clean the data.\nIf you can‚Äôt find a dataset, you can use the full, unmodified version of the workshop data here: https://osf.io/zem9p\n\n\n\nIf the EDA module is included in the workshop, then assignment 1 is extended to include EDA. Plot the distribution of at least two types of variables that you are interested in exploring further.\nCreate at least one plot with the relationship between two variables, and a summary table with the mean and standard deviation within groupings of a variable. \n\n\n\nIf the data modelling module is taught in the workshop, select at least two statistical models to apply to the data.\n\n\n\nUse Quarto to communicate the results from the previous sections of assignment 1. This can be in the form of a report, short manuscript, presentation, or whatever format in Quarto you prefer.",
    "crumbs": [
      "Assignments"
    ]
  },
  {
    "objectID": "assignments.html#assignment-2-reproduce-someone-elses-code",
    "href": "assignments.html#assignment-2-reproduce-someone-elses-code",
    "title": "Assignments",
    "section": "Assignment 2: Reproduce someone else‚Äôs code",
    "text": "Assignment 2: Reproduce someone else‚Äôs code\nYou will be paired up with another person in the workshop. Send each other your project and try to run the other‚Äôs code.\nMake a note of any issues you encounter, and provide feedback in a document.\nIncorporate feedback.\nIf the workshop includes the collaborative coding module, then this assignment should be done with Git and whatever Git hosting platform is preferred (GitHub, GitLab, etc).",
    "crumbs": [
      "Assignments"
    ]
  },
  {
    "objectID": "docs/05_visualising-data.html",
    "href": "docs/05_visualising-data.html",
    "title": "EDA: Visualising data with ggplot2",
    "section": "",
    "text": "Artwork by @allison_horst.\nPlotting is a great way of exploring the distribution of, and relationships between our variables. They also often offer a lot more insights into our variables than many statistical tests, and are therefore a crucial part of data analysis.",
    "crumbs": [
      "Materials",
      "05 - Visualising Data"
    ]
  },
  {
    "objectID": "docs/05_visualising-data.html#setup",
    "href": "docs/05_visualising-data.html#setup",
    "title": "EDA: Visualising data with ggplot2",
    "section": "Setup",
    "text": "Setup\nStart a new script and save it as 01_data-viz.R in the scripts/ folder.\nThe ggplot2 package is part of tidyverse, so we can just load tidyverse and upload our data. We are doing this again so the new script will be self-contained and not rely on the previous script we created.\nlibrary(tidyverse)\nlibrary(here)\n\nmortuary_data &lt;- read_csv(here(\"data/data_clean.csv\"))",
    "crumbs": [
      "Materials",
      "05 - Visualising Data"
    ]
  },
  {
    "objectID": "docs/05_visualising-data.html#basic-usage-of-ggplot2",
    "href": "docs/05_visualising-data.html#basic-usage-of-ggplot2",
    "title": "EDA: Visualising data with ggplot2",
    "section": "Basic usage of ggplot2",
    "text": "Basic usage of ggplot2\nThe anatomy of a standard ggplot (with pipe) is:\ndata |&gt;\n  ggplot(aes(&lt;mappings&gt;)) +\n    &lt;geometric function&gt; +\n    &lt;customisations&gt;\nWhere mappings are our variables, for example on the X and Y axes. We start with our data, the mortuary_data data frame and pipe that into ggplot(). We can do this because data is the first argument in ggplot().\n\nmortuary_data |&gt;\n  ggplot()\n\n\n\n\n\n\n\n\nThis gives us a blank grey background, because all we‚Äôve told R is that we want a plot. We can define how our variables are mapped to the visual properties of the plot by adding variables to the mapping argument through the aesthetics function. In short, we will define the x- and y-axis.\n\nmortuary_data |&gt;\n  ggplot(mapping = aes(x = Length, y = Width))\n\n\n\n\n\n\n\n\nThis gives a little more structure to the plot, since the variables can define the limits of the axes.\nThen we can define the geometrical object used to represent our data; essentially what type of plot we want to use. We can do this using the geom_*() functions. To produce a scatter plot we can use geom_point().\n\nmortuary_data |&gt;\n  ggplot(mapping = aes(x = Length, y = Width)) +\n    geom_point()\n\nWarning: Removed 13 rows containing missing values or values outside the scale range\n(`geom_point()`).\n\n\n\n\n\n\n\n\n\nWe now have a base plot to which we can add additional mappings and layers to increase the complexity and improve the aesthetics of the plot. First, let‚Äôs focus on the different types of variables and how we can plot them.",
    "crumbs": [
      "Materials",
      "05 - Visualising Data"
    ]
  },
  {
    "objectID": "docs/05_visualising-data.html#categorical-variables",
    "href": "docs/05_visualising-data.html#categorical-variables",
    "title": "EDA: Visualising data with ggplot2",
    "section": "Categorical variables",
    "text": "Categorical variables\nA common way to visualise a single categorical variable is with a bar plot.\n\nmortuary_data |&gt;\n  ggplot(aes(x = Phase)) +\n    geom_bar()\n\n\n\n\n\n\n\n\nThis gives us a quick count of burials (rows) in each Phase of occupation.\nBecause Phase is a factor, geom_bar() will count how many times each level of Phase occurs.\n\nFactors\nA factor is a type of data that has categories encoded in the object. If we take a look at Phase, we can see that it has many strings that are not unique. They are confined to the values chi, disturbed, euro, post, pre.\nThose values are called the levels() of a variable.\n\nlevels(mortuary_data$Phase)\n\nNULL\n\n\nIf the output is NULL it means our variable is not a factor.\nWe can convert a variable to a factor using as_factor() from the forcats package (part of tidyverse), or as.factor() from base R. It‚Äôs only temporary because we‚Äôre not assigning it to an object.\n\nas_factor(mortuary_data$Phase)\n\n  [1] pre       euro      post      euro      euro      euro      pre      \n  [8] euro      pre       post      euro      pre       euro      euro     \n [15] euro      euro      euro      euro      pre       euro      euro     \n [22] euro      pre       euro      pre       pre       euro      euro     \n [29] euro      pre       euro      pre       euro      euro      &lt;NA&gt;     \n [36] &lt;NA&gt;      euro      euro      &lt;NA&gt;      euro      euro      euro     \n [43] euro      pre       &lt;NA&gt;      &lt;NA&gt;      pre       &lt;NA&gt;      euro     \n [50] pre       pre       &lt;NA&gt;      &lt;NA&gt;      euro      euro      euro     \n [57] euro      &lt;NA&gt;      &lt;NA&gt;      &lt;NA&gt;      euro      &lt;NA&gt;      pre      \n [64] post      euro      pre       &lt;NA&gt;      pre       euro      pre      \n [71] &lt;NA&gt;      chi       chi       chi       chi       euro      pre      \n [78] pre       pre       pre       post      post      pre       disturbed\n [85] disturbed disturbed disturbed euro      pre       pre       &lt;NA&gt;     \n [92] euro      euro      pre       pre       pre       pre       &lt;NA&gt;     \n [99] &lt;NA&gt;      euro      euro      euro      euro      &lt;NA&gt;      &lt;NA&gt;     \n[106] &lt;NA&gt;      &lt;NA&gt;      disturbed &lt;NA&gt;      &lt;NA&gt;      &lt;NA&gt;      &lt;NA&gt;     \n[113] &lt;NA&gt;      &lt;NA&gt;      &lt;NA&gt;      &lt;NA&gt;      &lt;NA&gt;      &lt;NA&gt;      disturbed\n[120] disturbed &lt;NA&gt;      &lt;NA&gt;      &lt;NA&gt;      &lt;NA&gt;      disturbed\nLevels: pre euro post chi disturbed\n\n\nWe can see some additional information about the levels that is not included in a regular character vector: Levels: pre euro post chi disturbed. We can now extract this information using levels().\n\nlevels(as_factor(mortuary_data$Phase))\n\n[1] \"pre\"       \"euro\"      \"post\"      \"chi\"       \"disturbed\"\n\n\nWe can also count the number of levels with nlevels().\n\nnlevels(as_factor(mortuary_data$Phase))\n\n[1] 5\n\n\nAnd we can order the levels of our factor\n\nfactor(\n  mortuary_data$Phase,\n  levels = c(\"chi\", \"pre\", \"euro\", \"post\", \"disturbed\"),\n  ordered = T # the order given in levels becomes the order of the levels\n)\n\n  [1] pre       euro      post      euro      euro      euro      pre      \n  [8] euro      pre       post      euro      pre       euro      euro     \n [15] euro      euro      euro      euro      pre       euro      euro     \n [22] euro      pre       euro      pre       pre       euro      euro     \n [29] euro      pre       euro      pre       euro      euro      &lt;NA&gt;     \n [36] &lt;NA&gt;      euro      euro      &lt;NA&gt;      euro      euro      euro     \n [43] euro      pre       &lt;NA&gt;      &lt;NA&gt;      pre       &lt;NA&gt;      euro     \n [50] pre       pre       &lt;NA&gt;      &lt;NA&gt;      euro      euro      euro     \n [57] euro      &lt;NA&gt;      &lt;NA&gt;      &lt;NA&gt;      euro      &lt;NA&gt;      pre      \n [64] post      euro      pre       &lt;NA&gt;      pre       euro      pre      \n [71] &lt;NA&gt;      chi       chi       chi       chi       euro      pre      \n [78] pre       pre       pre       post      post      pre       disturbed\n [85] disturbed disturbed disturbed euro      pre       pre       &lt;NA&gt;     \n [92] euro      euro      pre       pre       pre       pre       &lt;NA&gt;     \n [99] &lt;NA&gt;      euro      euro      euro      euro      &lt;NA&gt;      &lt;NA&gt;     \n[106] &lt;NA&gt;      &lt;NA&gt;      disturbed &lt;NA&gt;      &lt;NA&gt;      &lt;NA&gt;      &lt;NA&gt;     \n[113] &lt;NA&gt;      &lt;NA&gt;      &lt;NA&gt;      &lt;NA&gt;      &lt;NA&gt;      &lt;NA&gt;      disturbed\n[120] disturbed &lt;NA&gt;      &lt;NA&gt;      &lt;NA&gt;      &lt;NA&gt;      disturbed\nLevels: chi &lt; pre &lt; euro &lt; post &lt; disturbed\n\n\nNotice the difference between an ordered and unordered factor\nUnordered: Levels: pre euro post chi disturbed Ordered: Levels: chi &lt; pre &lt; euro &lt; post &lt; disturbed\n\n\nTwo categorical variables\nFor two categorical variables we can use‚Ä¶ bar plots! We can add a variable by mapping it in the aesthetics.\n\nmortuary_data |&gt;\n  ggplot(aes(x = Phase, fill = Condition)) +\n    geom_bar()\n\nWarning: The following aesthetics were dropped during statistical transformation: fill.\n‚Ñπ This can happen when ggplot fails to infer the correct grouping structure in\n  the data.\n‚Ñπ Did you forget to specify a `group` aesthetic or to convert a numerical\n  variable into a factor?\n\n\n\n\n\n\n\n\n\nBased on the warning message, it seems ggplot() was unable to automatically convert Condition to a factor. This is probably because the levels of conditions are numeric, and not strings like Phase. We need to explicitly convert Condition to a factor.\nWe could do this as part of the pipe\n\nmortuary_data |&gt;\n  mutate(Condition = as_factor(Condition)) |&gt;\n  ggplot(aes(x = Phase, fill = Condition)) +\n    geom_bar()\n\n\n\n\n\n\n\n\nor do it in aes()\n\nmortuary_data |&gt;\n  ggplot(aes(x = Phase, fill = as_factor(Condition))) +\n    geom_bar()\n\n\n\n\n\n\n\n\nNow we have a bar plot with two variables. If it‚Äôs difficult to assess counts of the different conditions, we can change it from a stacked bar plot to‚Ä¶ whatever this is:\n\nmortuary_data |&gt;\n  ggplot(aes(x = Phase, fill = as_factor(Condition))) +\n    geom_bar(position = \"dodge\")\n\n\n\n\n\n\n\n\nAnd if we, like in this case, have highly variable counts (there are clearly a larger number of burials in the euro and pre groups) we can use proportions instead of absolute counts.\n\nmortuary_data |&gt;\n  ggplot(aes(x = Phase, fill = as_factor(Condition))) +\n    geom_bar(position = \"fill\")\n\n\n\n\n\n\n\n\nThis standardises the counts across all phases and allows us to compare counts across Phase.\nThere are also pie charts, but these should be used very sparingly because it is difficult to distinguish between levels of a categorical variable if there are too many. They are also weirdly complicated to make with ggplot2.\n\nmortuary_data |&gt;\n  ggplot(aes(x = \"\", fill = Phase)) +\n    geom_bar(width = 1) +\n    coord_polar(\"y\", start = 0) +\n    theme_void()\n\n\n\n\n\n\n\n\nQuick, which is bigger, NA or euro? What about chi, disturbed, and post?",
    "crumbs": [
      "Materials",
      "05 - Visualising Data"
    ]
  },
  {
    "objectID": "docs/05_visualising-data.html#continuous-variables",
    "href": "docs/05_visualising-data.html#continuous-variables",
    "title": "EDA: Visualising data with ggplot2",
    "section": "Continuous variables",
    "text": "Continuous variables\n\nHistogram\nPerhaps one of the simplest ways to visualise continuous variables is with a histogram. All you need is one continuous variable, for example Length.\n\nmortuary_data |&gt;\n  ggplot(aes(x = Length)) +\n    geom_histogram()\n\n`stat_bin()` using `bins = 30`. Pick better value with `binwidth`.\n\n\nWarning: Removed 13 rows containing non-finite outside the scale range\n(`stat_bin()`).\n\n\n\n\n\n\n\n\n\nThis allows us to see the distribution of a continuous variable with the observations grouped into ‚Äòbins‚Äô of a specific size. The taller the bars, the more observations are in the bins. We can create larger bins or reduce the number of bins, which will change the shape of the plot. Typically you might want to adjust this if you have many gaps in your histogram.\n\nmortuary_data |&gt;\n  ggplot(aes(x = Length)) +\n    geom_histogram(bins = 10)\n\nWarning: Removed 13 rows containing non-finite outside the scale range\n(`stat_bin()`).\n\n\n\n\n\n\n\n\n\nYou can also reduce the bin size or increase the number of bins\n\nmortuary_data |&gt;\n  ggplot(aes(x = Length)) +\n    geom_histogram(bins = 40)\n\nWarning: Removed 13 rows containing non-finite outside the scale range\n(`stat_bin()`).\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nBeware mixing symbols\n\n\n\nA common mistake when creating a ggplot is to use the pipe, |&gt;, instead of the plus symbol, +, for layering elements of the plot. Fortunately, there is a helpful error message.\n\nmortuary_data |&gt;\n  ggplot(mapping = aes(x = Length, y = Width)) |&gt;\n    geom_point()\n\n\n\nError in geom_point(ggplot(mortuary_data, mapping = aes(x = Length, y = Width))) : \n  `mapping` must be created by `aes()`.\n‚Ñπ Did you use `%&gt;%` or `|&gt;` instead of `+`?\n\n\n\n\n\n\nDensity\nIf you‚Äôre not a fan of the bars (and the middle-finger aesthetic) you can instead choose a density plot, which uses a kernel density estimate to provide a smoothed version of a histogram.\n\nmortuary_data |&gt;\n  ggplot(aes(x = Length)) +\n    geom_density()\n\nWarning: Removed 13 rows containing non-finite outside the scale range\n(`stat_density()`).\n\n\n\n\n\n\n\n\n\nInstead of binning observations we are provided with a continuous density of observations. We can see from the plot that we pretty much have a normal distribution. This becomes especially clear if we insert the mean value. We can do that by using geom_vline() to insert a dashed vertical line at the mean of Length.\n\nmortuary_data |&gt;\n  ggplot(aes(x = Length)) +\n    geom_density() +\n    geom_vline(\n      xintercept = mean(mortuary_data$Length, na.rm = T),\n      linetype = \"dashed\"\n    )\n\nWarning: Removed 13 rows containing non-finite outside the scale range\n(`stat_density()`).\n\n\n\n\n\n\n\n\n\nWe can compare the distribution of a variable between groups using the fill aesthetic. For example, we can compare the two excavation Layers.\n\nmortuary_data |&gt;\n  ggplot(aes(x = Length, fill = as_factor(Layer))) +\n    geom_density()\n\nWarning: Removed 13 rows containing non-finite outside the scale range\n(`stat_density()`).\n\n\n\n\n\n\n\n\n\nTo make each distribution more visible, we can make the fill of each distribution more transparent using the alpha argument.\n\nmortuary_data |&gt;\n  ggplot(aes(x = Length, fill = as_factor(Layer))) +\n    geom_density(alpha = 0.6)\n\nWarning: Removed 13 rows containing non-finite outside the scale range\n(`stat_density()`).\n\n\n\n\n\n\n\n\n\nWhat alpha does is control the level of opacity of the fill, where 1 is a solid colour and 0 is completely transparent.\n\n\n\n\n\n\nExercise\n\n\n\nUse the colour aesthetic to visulise the distribution of Height across all Phases of occupation, except \"disturbed\".\nNext use the fill aesthetic. What is the difference? (remember to add transparency)\n\n\n\n\n\n\nSolution\n\n\n\n\n\n\nmortuary_data |&gt;\n  filter(Phase != \"disturbed\") |&gt;\n  ggplot(aes(x = Length, colour = Phase)) +\n    geom_density(alpha = 0.6)\n\nWarning: Removed 5 rows containing non-finite outside the scale range\n(`stat_density()`).\n\n\n\n\n\n\n\n\n\n\nmortuary_data |&gt;\n  filter(Phase != \"disturbed\") |&gt;\n  ggplot(aes(x = Length, fill = Phase)) +\n    geom_density(alpha = 0.6)\n\nWarning: Removed 5 rows containing non-finite outside the scale range\n(`stat_density()`).\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nIf there are too many levels in a fill variable, a better option may be to separate them with facet_wrap.\n\nmortuary_data |&gt;\n  filter(Phase != \"disturbed\") |&gt;\n  ggplot(aes(x = Length, fill = Phase)) +\n    geom_density(alpha = 0.6) +\n    facet_wrap(~ Phase)\n\nWarning: Removed 5 rows containing non-finite outside the scale range\n(`stat_density()`).\n\n\n\n\n\n\n\n\n\nFor an even better comparison we can force them into a single column.\n\nmortuary_data |&gt;\n  filter(Phase != \"disturbed\") |&gt;\n  ggplot(aes(x = Length, fill = Phase)) +\n    geom_density(alpha = 0.6) +\n    facet_wrap(~ Phase, ncol = 1)\n\nWarning: Removed 5 rows containing non-finite outside the scale range\n(`stat_density()`).\n\n\n\n\n\n\n\n\n\nTo visualise two continuous variables, we can use a scatterplot, which was already introduced in An Example Workflow.\n\nmortuary_data |&gt;\n  ggplot(aes(x = Length, y = Width)) +\n    geom_point()\n\nWarning: Removed 13 rows containing missing values or values outside the scale range\n(`geom_point()`).\n\n\n\n\n\n\n\n\n\nThe plot is admittedly a bit dull. To fix this we can add some colour to our geomteric object. We can add the same colour to all the points\n\nmortuary_data |&gt;\n  ggplot(aes(x = Length, y = Width)) +\n    geom_point(colour = \"red\")\n\nWarning: Removed 13 rows containing missing values or values outside the scale range\n(`geom_point()`).\n\n\n\n\n\n\n\n\n\nor to groupings in the data by mapping a variable to colour in the aesthetics.\n\nmortuary_data |&gt;\n  ggplot(aes(x = Length, y = Width)) +\n    geom_point(aes(colour = Phase))\n\nWarning: Removed 13 rows containing missing values or values outside the scale range\n(`geom_point()`).\n\n\n\n\n\n\n\n\n\nSimilarly we can change the size and shape of all the points\n\nmortuary_data |&gt;\n  ggplot(aes(x = Length, y = Width)) +\n    geom_point(aes(col = Phase), size = 4, shape = 2)\n\nWarning: Removed 13 rows containing missing values or values outside the scale range\n(`geom_point()`).\n\n\n\n\n\n\n\n\n\nor map a variable to size and shape\n\nmortuary_data |&gt;\n  ggplot(aes(x = Length, y = Width)) +\n    geom_point(aes(col = Phase, size = Height, shape = as_factor(Layer)))\n\nWarning: Removed 14 rows containing missing values or values outside the scale range\n(`geom_point()`).\n\n\n\n\n\n\n\n\n\nBut don‚Äôt go overboard or you‚Äôll make it completely unreadible!",
    "crumbs": [
      "Materials",
      "05 - Visualising Data"
    ]
  },
  {
    "objectID": "docs/05_visualising-data.html#mixed-categorical-and-continuous-variables",
    "href": "docs/05_visualising-data.html#mixed-categorical-and-continuous-variables",
    "title": "EDA: Visualising data with ggplot2",
    "section": "Mixed categorical and continuous variables",
    "text": "Mixed categorical and continuous variables\nWhen mixing categorical and continuous variables, a box plot is a reasonable choice, with notable limitations.\n\nmortuary_data |&gt;\n  ggplot(aes(y = Length, x = Phase)) +\n    geom_boxplot()\n\nWarning: Removed 13 rows containing non-finite outside the scale range\n(`stat_boxplot()`).\n\n\n\n\n\n\n\n\n\nBox plots are useful, but contain limited information. How many observations are there? How are the observations distributed?\n\n\n\nArtwork by @allison_horst.\n\n\nThis is where the layering mechanism of ggplot2 really shines. We can add points to the plot with geom_point().\n\nmortuary_data |&gt;\n  ggplot(aes(y = Length, x = Phase)) +\n    geom_boxplot() + \n    geom_point()\n\nWarning: Removed 13 rows containing non-finite outside the scale range\n(`stat_boxplot()`).\n\n\nWarning: Removed 13 rows containing missing values or values outside the scale range\n(`geom_point()`).\n\n\n\n\n\n\n\n\n\nBut this isn‚Äôt much better. Because the x-axis is discrete, all the points are lined up in a few columns. A better option is geom_jitter().\n\nmortuary_data |&gt;\n  ggplot(aes(y = Length, x = Phase)) +\n    geom_boxplot() + \n    geom_jitter()\n\nWarning: Removed 13 rows containing non-finite outside the scale range\n(`stat_boxplot()`).\n\n\nWarning: Removed 13 rows containing missing values or values outside the scale range\n(`geom_point()`).\n\n\n\n\n\n\n\n\n\ngeom_jitter() is similar to geom_point(), but instead of plotting the points at there exact x and y values, it adds some random noise to each point on the x- and y-axis, which allows us to see all the observations, which otherwise would have been on top of one another.\nWe can reduce the amount of random noise with the height and width arguments. This is particularly useful if it‚Äôs hard to tell what the original value was, or if, like in our case, it‚Äôs hard to tell which category a point belongs to.\n\nmortuary_data |&gt;\n  ggplot(aes(y = Length, x = Phase)) +\n    geom_boxplot() +\n    geom_jitter(\n      width = 0.2,\n      height = 0.2\n    )\n\nWarning: Removed 13 rows containing non-finite outside the scale range\n(`stat_boxplot()`).\n\n\nWarning: Removed 13 rows containing missing values or values outside the scale range\n(`geom_point()`).\n\n\n\n\n\n\n\n\n\nNow it‚Äôs very clear to which Phase each point belongs, but we‚Äôre also still able to see all of the points in our data.\n\n\n\n\n\n\nOrder matters\n\n\n\nPSA: Beware the order in which you layer your geometric objects.\n\nmortuary_data |&gt;\n  ggplot(aes(y = Length, x = Phase)) +\n  geom_jitter(\n    width = 0.2,\n    height = 0.2\n  ) +\n  geom_boxplot() # the boxes will be in front of the points\n\nWarning: Removed 13 rows containing non-finite outside the scale range\n(`stat_boxplot()`).\n\n\nWarning: Removed 13 rows containing missing values or values outside the scale range\n(`geom_point()`).\n\n\n\n\n\n\n\n\n\n\n\nOne final note when overlaying a box plot with points. The outliers of the box plot will be visible along with the actual outlier shown with geom_jitter(). Therefore it‚Äôs necessary to suppress the outliers from the box plot.\n\nmortuary_data |&gt;\n  ggplot(aes(y = Length, x = Phase)) +\n    geom_boxplot(\n      outlier.shape = NA\n    ) +\n    geom_jitter(\n      width = 0.2,\n      height = 0.2\n    )\n\nWarning: Removed 13 rows containing non-finite outside the scale range\n(`stat_boxplot()`).\n\n\nWarning: Removed 13 rows containing missing values or values outside the scale range\n(`geom_point()`).\n\n\n\n\n\n\n\n\n\nWe could also have used outlier.colour = \"transparent\" for the same result.\nIf there were too many points on the plot, we could use geom_violin instead of geom_jitter to show the underlying distribution.\n\nmortuary_data |&gt;\n  ggplot(aes(y = Length, x = Phase)) +\n    geom_violin() +\n    geom_boxplot(\n      outlier.shape = NA\n    )\n\nWarning: Removed 13 rows containing non-finite outside the scale range\n(`stat_ydensity()`).\n\n\nWarning: Removed 13 rows containing non-finite outside the scale range\n(`stat_boxplot()`).\n\n\n\n\n\n\n\n\n\nAnd make some adjustments to the boxplot size and violin fill to make the plot more legible, and remove the legend since it doesn‚Äôt contain any extra information.\n\nmortuary_data |&gt;\n  ggplot(aes(y = Length, x = Phase)) +\n    geom_violin(aes(fill = Phase)) +\n    geom_boxplot(\n      width = 0.2,\n      outlier.shape = NA\n    ) +\n    theme(legend.position = \"none\")\n\nWarning: Removed 13 rows containing non-finite outside the scale range\n(`stat_ydensity()`).\n\n\nWarning: Removed 13 rows containing non-finite outside the scale range\n(`stat_boxplot()`).\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nExercise\n\n\n\nCreate a scatterplot showing the relationship between the Length and Width variables with a lm trendline, and with each category of Phase in a different shape and colour.\n\n\n\n\n\n\nSolution\n\n\n\n\n\n\nmortuary_data |&gt;\n  ggplot(aes(x = Length, y = Width)) +\n    geom_point(\n      aes(colour = Phase, shape = Phase),\n      size = 2\n    ) +\n    geom_smooth(method = \"lm\") +\n    theme_minimal()\n\n`geom_smooth()` using formula = 'y ~ x'\n\n\nWarning: Removed 13 rows containing non-finite outside the scale range\n(`stat_smooth()`).\n\n\nWarning: Removed 45 rows containing missing values or values outside the scale range\n(`geom_point()`).\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nSince our new dataset has a number of missing variables, the plot looks a little different. Adding a shape seems to have removed our NAs, which is not what we want. We need to define the shape that is used for missing values with a scale function. Scales help control the mapping of data to aesthetics, including size, colour, and shape. To modify the shape of a discrete variable Phase, we use the scale_shape_discrete() function and the na.value argument.\n\nmortuary_data |&gt;\n  ggplot(aes(x = Length, y = Width)) +\n    geom_point(aes(colour = Phase, shape = Phase)) +\n    geom_smooth(method = \"lm\") +\n    scale_shape_discrete(na.value = 10)\n\n\n\n\n\n\n\n\nGiving the value 10 is just defining which shape we want to use. The book ggplot2: Elegant Graphics for Data Analysis has a legend of the available shapes and their values (and lots of other useful info!)",
    "crumbs": [
      "Materials",
      "05 - Visualising Data"
    ]
  },
  {
    "objectID": "docs/05_visualising-data.html#alternate-examples",
    "href": "docs/05_visualising-data.html#alternate-examples",
    "title": "EDA: Visualising data with ggplot2",
    "section": "Alternate examples",
    "text": "Alternate examples\nWe could look at the trendlines for each level of Phase.\n\nmortuary_data |&gt;\n  ggplot(aes(x = Length, y = Width, colour = Phase)) +\n    geom_point() +\n    geom_smooth(method = \"lm\")\n\n`geom_smooth()` using formula = 'y ~ x'\n\n\nWarning: Removed 13 rows containing non-finite outside the scale range\n(`stat_smooth()`).\n\n\nWarning: Removed 13 rows containing missing values or values outside the scale range\n(`geom_point()`).\n\n\n\n\n\n\n\n\n\nThe error bands are making it kinda difficult to see the plot, so we can remove them with se = FALSE.\n\nmortuary_data |&gt;\n  ggplot(aes(x = Length, y = Width, colour = Phase)) +\n    geom_point() +\n    geom_smooth(method = \"lm\", se = FALSE)\n\n`geom_smooth()` using formula = 'y ~ x'\n\n\nWarning: Removed 13 rows containing non-finite outside the scale range\n(`stat_smooth()`).\n\n\nWarning: Removed 13 rows containing missing values or values outside the scale range\n(`geom_point()`).\n\n\n\n\n\n\n\n\n\nOr, we could instead remove the Phase that is causing the huge error bands; in this case, disturbed.\n\nmortuary_data |&gt;\n  filter(Phase != \"disturbed\") |&gt;\n  ggplot(aes(x = Length, y = Width, colour = Phase)) +\n    geom_point() +\n    geom_smooth(method = \"lm\")\n\n\n\n\n\n\n\n\nor we could zoom in using coord_cartesian() by defining the limits of the axes we want to show on the plot.\n\nmortuary_data |&gt;\n  ggplot(aes(x = Length, y = Width, colour = Phase)) +\n    geom_point() +\n    geom_smooth(method = \"lm\") +\n    coord_cartesian(ylim = c(0,100))\n\n\n\n\n\n\n\n\nThe benefit of the latter approach is that we are still seeing the plot with the full data and just zooming in to get a better look.\nBecause we are providing the colour mapping in the ggplot(), all geoms inherit this value. If we just want to look at the overall relationship, we can move the colour mapping to geom_point(), which will allow us to keep the Phase colours and see the overall trendline for the data.\n\nmortuary_data |&gt;\n  ggplot(aes(x = Length, y = Width)) +\n    geom_point(aes(colour = Phase)) +\n    geom_smooth(method = \"lm\")\n\n\n\n\n\n\n\n\nNow for some finishing touches. There are many reasons why only using colours to convey information is a bad idea. Think about colour perception, and that publishers charge you extra for colour printing. So let‚Äôs make each Phase a different shape as well.\n\nmortuary_data |&gt;\n  ggplot(aes(x = Length, y = Width)) +\n    geom_point(aes(colour = Phase, shape = Phase)) +\n    geom_smooth(method = \"lm\")\n\n\n\n\n\n\n\n\nThen we will modify the labels of the plot to convey a little more information.\n\nmortuary_data |&gt;\n  ggplot(aes(x = Length, y = Width)) +\n    geom_point(aes(colour = Phase, shape = Phase)) +\n    geom_smooth(method = \"lm\") +\n    labs(\n      x = \"Length in cm\",\n      y = \"Width in cm\",\n      colour = \"Phase of occupation\",\n      shape = \"Phase of occupation\" \n    ) # we have to change both colour and shape to keep a single legend\n\n\n\n\n\n\n\n\nAs a final touch, we will add a colour palette that is more friendly to colour-deficient vision and change the background of the plot (the grey background is surprisingly controversial in the R community).\n\nmortuary_data |&gt;\n  ggplot(aes(x = Length, y = Width)) +\n    geom_point(aes(colour = Phase, shape = Phase)) +\n    geom_smooth(method = \"lm\") +\n    labs(\n      x = \"Length in cm\",\n      y = \"Width in cm\",\n      colour = \"Phase of occupation\",\n      shape = \"Phase of occupation\" \n    ) +\n    scale_colour_viridis_d() + # new palette\n    scale_shape_discrete(na.value = 10) +\n    theme_minimal() # minimal background",
    "crumbs": [
      "Materials",
      "05 - Visualising Data"
    ]
  },
  {
    "objectID": "docs/05_visualising-data.html#saving-your-masterpiece-for-posterity",
    "href": "docs/05_visualising-data.html#saving-your-masterpiece-for-posterity",
    "title": "EDA: Visualising data with ggplot2",
    "section": "Saving your masterpiece for posterity",
    "text": "Saving your masterpiece for posterity\nTo save a plot we can use ggsave() and provide a file path for the figure output. By default it will save the most recent plot. To save a specific plot, we need to save the plot as an object and provide it as an argument to ggsave().\n\nmortuary_data |&gt;\n  ggplot(aes(x = Length, y = Width)) +\n    geom_point(aes(colour = Phase, shape = Phase)) +\n    geom_smooth(method = \"lm\") +\n    labs(\n      x = \"Length in cm\",\n      y = \"Width in cm\",\n      colour = \"Phase of occupation\",\n      shape = \"Phase of occupation\" \n    ) +\n    scale_colour_viridis_d() + # new palette\n    theme_minimal() # minimal background\n\n`geom_smooth()` using formula = 'y ~ x'\n\n\nWarning: Removed 13 rows containing non-finite outside the scale range\n(`stat_smooth()`).\n\n\nWarning: Removed 45 rows containing missing values or values outside the scale range\n(`geom_point()`).\n\n\n\n\n\n\n\n\n\nWe will save the plot in the figures/ folder and call it burial-dim-scatter.png.\n\nggsave(mortuary_sex_pl, here(\"figures/burial-dim-scatter.png\"))\n\nIf you‚Äôre submitting to a journal that has figure requirements, you can adjust the arguments such as height, width, and dpi.\n\nargs(ggsave)\n\nfunction (filename, plot = last_plot(), device = NULL, path = NULL, \n    scale = 1, width = NA, height = NA, units = c(\"in\", \"cm\", \n        \"mm\", \"px\"), dpi = 300, limitsize = TRUE, bg = NULL, \n    create.dir = FALSE, ...) \nNULL",
    "crumbs": [
      "Materials",
      "05 - Visualising Data"
    ]
  },
  {
    "objectID": "docs/03_rstudio-project.html",
    "href": "docs/03_rstudio-project.html",
    "title": "Getting organised with RStudio Projects",
    "section": "",
    "text": "RStudio Projects allow you to create self-contained, portable code projects. The main way it works is by allowing you to work with filepaths that are relative to the root directory of the project instead of relative to your system. It also saves settings specific to the project in the *.Rproj file.",
    "crumbs": [
      "Materials",
      "03 - Getting Organised"
    ]
  },
  {
    "objectID": "docs/03_rstudio-project.html#new-rstudio-project",
    "href": "docs/03_rstudio-project.html#new-rstudio-project",
    "title": "Getting organised with RStudio Projects",
    "section": "New RStudio Project",
    "text": "New RStudio Project\nCreate a new project:\nFile &gt; New Project &gt; New Directory &gt; New Project\nYou can call the project RchaeoStats-workshop (or something like that). Once the project is created, a fresh RStudio environment will open. You will now see a .Rproj in the file pane, and in the top right corner you will see the project name.",
    "crumbs": [
      "Materials",
      "03 - Getting Organised"
    ]
  },
  {
    "objectID": "docs/03_rstudio-project.html#opening-an-rstudio-project",
    "href": "docs/03_rstudio-project.html#opening-an-rstudio-project",
    "title": "Getting organised with RStudio Projects",
    "section": "Opening an RStudio Project",
    "text": "Opening an RStudio Project\nTo open an existing project:\nFile &gt; Open Project &gt; Navigate to the directory and select the *.Rproj* file\nOpening your project will set your working directory to the project root, and open any files you had open in RStudio when you last worked on the project.\n\n\n\n\n\n\nTip\n\n\n\nIf you have previously worked on a project, you can also open it again from the dropdown menu in the top right corner.\n\n\n\nClosing an RStudio Project\nUsing the dropdown menu in the top right corner, select Close Project.",
    "crumbs": [
      "Materials",
      "03 - Getting Organised"
    ]
  },
  {
    "objectID": "docs/03_rstudio-project.html#organising-the-project",
    "href": "docs/03_rstudio-project.html#organising-the-project",
    "title": "Getting organised with RStudio Projects",
    "section": "Organising the project",
    "text": "Organising the project\n\nWell begun is half done. - Mary Poppins\n\nA project should be organised in a way that makes sense for the project, there is no ‚Äòone size fits all‚Äô. A typical R project could look something like this:\nProject\n‚îú‚îÄ‚îÄ README.md\n‚îú‚îÄ‚îÄ analysis\n‚îÇ   ‚îî‚îÄ‚îÄ report.qmd\n‚îú‚îÄ‚îÄ scripts\n‚îÇ   ‚îî‚îÄ‚îÄ analysis.R\n‚îú‚îÄ‚îÄ data-raw\n‚îÇ   ‚îî‚îÄ‚îÄ raw-data.csv\n‚îú‚îÄ‚îÄ data\n‚îÇ   ‚îî‚îÄ‚îÄ cleaned-data.rda\n‚îî‚îÄ‚îÄ figures\nThere are many variations in the wild - some have been collected here\nWe can create the folder structure by using the Files pane in RStudio and clicking on the ‚ÄòCreate a new folder‚Äô icon, or from the console:\n\nnew_dirs &lt;- c(\"docs\", \"scripts\", \"data-raw\", \"data\", \"figures\")\nsapply(new_dirs, dir.create)\n\ndir.create() is the function that allows us to create new folders (or directories), but it only allows us to do so one folder at a time. To create multiple folders we can create a vector of the folder names, new_dirs and use sapply to iterate the dir.create function over all the elements of new_dirs. So it will first execute dir.create(\"docs\"), then dir.create(\"scripts\"), and so on until it reaches the last element of the vector, \"figures\".",
    "crumbs": [
      "Materials",
      "03 - Getting Organised"
    ]
  },
  {
    "objectID": "docs/03_rstudio-project.html#no-more-filepath-issues",
    "href": "docs/03_rstudio-project.html#no-more-filepath-issues",
    "title": "Getting organised with RStudio Projects",
    "section": "No more filepath issues",
    "text": "No more filepath issues\nsetwd() is the function used to set your working directory in R. The problem with setwd() is that you have to insert the path that is likely VERY specific to your computer, for example: setwd(\"C:\\Users\\username\\and\\you\\get\\the\\idea\\\"). If this is the first line of code in your R script, then it is not going to work on anyone else‚Äôs computer.\nBy combining the use of RStudio Projects and the here package, you can remove any (well, most‚Ä¶) filepath issues in your work and when you share your project with others.\nRStudio Projects generate a top-level directory at the root of your project, and here ensures that you only need to create filepaths that are relative to that top-level directory.\n\n\n\nArtwork by @allison_horst",
    "crumbs": [
      "Materials",
      "03 - Getting Organised"
    ]
  },
  {
    "objectID": "docs/03_rstudio-project.html#a-final-note",
    "href": "docs/03_rstudio-project.html#a-final-note",
    "title": "Getting organised with RStudio Projects",
    "section": "A final note",
    "text": "A final note\nA final, more general recommendation on the RStudio workflow, is to avoid saving you workspace when closing RStudio (you will be prompted to do this each time you close RStudio).\nTools &gt; Global Options‚Ä¶ &gt; General &gt; Workspace\nThen, uncheck the box next to Restore .RData into workspace at startup and set Save workspace to .RData on exit to ‚ÄòNever‚Äô.\nThe reason I recommend this is because all your work should be contained in an R script (or multiple R scripts in a project), and running said RScript(s) should reproduce everything you need in your Global Environment. This will help keep your workflow clean and reproducible!",
    "crumbs": [
      "Materials",
      "03 - Getting Organised"
    ]
  },
  {
    "objectID": "docs/08_communicating-results.html",
    "href": "docs/08_communicating-results.html",
    "title": "Communicating Results with Quarto",
    "section": "",
    "text": "Prerequisites\n\n\n\n\n\n\n\nCore + Visualising data\n\n\n\nProject organisation + Data cleaning\nAn important part of the data analysis is communicating our findings effectively. A common way is to manually add figures and tables to a Word or LaTeX document and write up the results. This can be tedious, especially if you find an error in your data and/or analysis; then the figures may need to be changed and possibly all of the values in the tables.\nQuarto is a software that allows you to combine code, code output, and text within a single document, that can be dynamically rendered to various output formats (including HTML, PDF, and DOCX).\nSince we already specified a title in the YAML header there is no need to include another one.\nis equivalent to\nThe next logical section would be an introduction.\nWe can add some markup to determine how the text will eventually be rendered. To italicise a word, surround the word in single *asterisks*. To bold a word, surround it in double **asterisks**. To do both, add triples to the ***word***, then people will know you REALLY mean business!\nWhen you start a new line in markdown, it will not start a new line in the rendered document. To insert a linebreak, there should be two spaces after the last word.\nCreating a paragraph is the same as you would normally do it in a word processor.\nNow we need a Materials section. We can create a list using the hyphen, -. There should be a horizontal space between the hyphen and list item.\nLists can also have nested items with two horizontal spaces. You can choose between the hyphen, -, the plus symbol, +, and the asterisk, * when creating a list. There is no difference between them. I like to use alternating symbols for nested lists because makes clear which items are on the same level and increases human readability.\nAnd they can be ranked\nA methods section is an important place to mention that you are using R!\nWhen you render the document, the version will always show whatever version you were using when you rendered the document. This can also be used to display statistics, which we will see later.\nFinally to the fun part. The results! Here we can really show the benefit of combining code and output in a single document.",
    "crumbs": [
      "Materials",
      "08 - Communicating Results"
    ]
  },
  {
    "objectID": "docs/08_communicating-results.html#creating-a-quarto-document",
    "href": "docs/08_communicating-results.html#creating-a-quarto-document",
    "title": "Communicating Results with Quarto",
    "section": "Creating a Quarto document",
    "text": "Creating a Quarto document\nFile &gt; New File &gt; Quarto Document‚Ä¶\nCreate Empty Document.\nSave it as report.qmd in the folder called docs.\nAt the beginning of the document, before any code or text, we need to specify our document markup with a YAML (YAML Ain‚Äôt Markup Language) header. The YAML header is contained using two sets of three hyphens:\n---\n\nYAML header\n\n---\nHere we can specify document metadata, such as title, author, and date.\n---\ntitle: Symbolic Material Culture within an Ancient Catastrophic Temple Complex\nauthor: Dr. Henry Walton Jones Jr.\ndate: 1984\n---",
    "crumbs": [
      "Materials",
      "08 - Communicating Results"
    ]
  },
  {
    "objectID": "docs/08_communicating-results.html#adding-content",
    "href": "docs/08_communicating-results.html#adding-content",
    "title": "Communicating Results with Quarto",
    "section": "Adding content",
    "text": "Adding content\nWe can start adding text below the YAML header. Text is added using Markdown, a popular, cross-platform markup language. RStudio has a visual editor where you can add formatting in much the same way as a word processor (e.g.¬†Word), but I think it‚Äôs important to see the conversion from Markdown to rendered document.\nTo create a headers we use the pound symbol, #.\n# Title\n## Section\n### Subsection\n#### Subsubsection\n##### etc.\nWhich becomes‚Ä¶",
    "crumbs": [
      "Materials",
      "08 - Communicating Results"
    ]
  },
  {
    "objectID": "docs/08_communicating-results.html#section",
    "href": "docs/08_communicating-results.html#section",
    "title": "Communicating Results with Quarto",
    "section": "Section",
    "text": "Section\n\nSubsection\n\nSubsubsection\n\netc.",
    "crumbs": [
      "Materials",
      "08 - Communicating Results"
    ]
  },
  {
    "objectID": "docs/08_communicating-results.html#methods",
    "href": "docs/08_communicating-results.html#methods",
    "title": "Communicating Results with Quarto",
    "section": "Methods",
    "text": "Methods\nI recently learned how to use R and couldn‚Äôt wait to use it in this study! I am using R version X.Y (YYYY-MM-DD).",
    "crumbs": [
      "Materials",
      "08 - Communicating Results"
    ]
  },
  {
    "objectID": "docs/08_communicating-results.html#methods-1",
    "href": "docs/08_communicating-results.html#methods-1",
    "title": "Communicating Results with Quarto",
    "section": "Methods",
    "text": "Methods\nI recently learned about the R programming language and couldn‚Äôt wait to use it in this study! I am using R version 4.4.2 (2024-10-31).",
    "crumbs": [
      "Materials",
      "08 - Communicating Results"
    ]
  },
  {
    "objectID": "docs/08_communicating-results.html#other-outputs",
    "href": "docs/08_communicating-results.html#other-outputs",
    "title": "Communicating Results with Quarto",
    "section": "Other outputs",
    "text": "Other outputs\nThe output format can be modified in the YAML header. If, for some reason, we need the output to be docx or pdf, we can specify that.\n---\n...\nformat:\n  docx: default\n  pdf: default\n---\nTo be able to produce PDFs, we need to have a latex compiler installed. This can be done with the tinytex R package.\n\ninstall.packages(\"tinytex\")\ntinytex::install_tinytex()",
    "crumbs": [
      "Materials",
      "08 - Communicating Results"
    ]
  },
  {
    "objectID": "docs/01_r-basics.html",
    "href": "docs/01_r-basics.html",
    "title": "Basics of R",
    "section": "",
    "text": "Artwork by @allison_horst",
    "crumbs": [
      "Materials",
      "01 - R Basics"
    ]
  },
  {
    "objectID": "docs/01_r-basics.html#navigating-rstudio",
    "href": "docs/01_r-basics.html#navigating-rstudio",
    "title": "Basics of R",
    "section": "Navigating RStudio",
    "text": "Navigating RStudio\n\nThe first time you open RStudio there will be three panes:\n\nthe Console: left\n\nthis is R\nhere you can execute R code\n\nthe Environment pane: right-top\n\nvariables are stored here\n\nthe Files pane: right-bottom\n\nthis is your working directory",
    "crumbs": [
      "Materials",
      "01 - R Basics"
    ]
  },
  {
    "objectID": "docs/01_r-basics.html#console",
    "href": "docs/01_r-basics.html#console",
    "title": "Basics of R",
    "section": "Console",
    "text": "Console\nThe console is where you interact directly with R\nThe greater-than symbol, &gt;, indicates that are is ready for your input.\nThe symbol will not be present where you have your output. Instead, you will see a one in square brackets, [1], which indicates the first element of our output.",
    "crumbs": [
      "Materials",
      "01 - R Basics"
    ]
  },
  {
    "objectID": "docs/01_r-basics.html#console-1",
    "href": "docs/01_r-basics.html#console-1",
    "title": "Basics of R",
    "section": "Console",
    "text": "Console\nSee what happens when we have an output with multiple elements; for example, we can print the whole numbers from 42 to 100:\n\n42:100\n\n [1]  42  43  44  45  46  47  48  49  50  51  52  53  54  55  56  57  58  59  60\n[20]  61  62  63  64  65  66  67  68  69  70  71  72  73  74  75  76  77  78  79\n[39]  80  81  82  83  84  85  86  87  88  89  90  91  92  93  94  95  96  97  98\n[58]  99 100\n\n\n42 is next to the [1] and the next row will show the nth element of the output.\nIf you see a plus sign, +, it means the console is waiting for more input.\nIf you don‚Äôt want to enter more code, press Esc.",
    "crumbs": [
      "Materials",
      "01 - R Basics"
    ]
  },
  {
    "objectID": "docs/01_r-basics.html#mathematical-operations",
    "href": "docs/01_r-basics.html#mathematical-operations",
    "title": "Basics of R",
    "section": "Mathematical operations",
    "text": "Mathematical operations\nR can be used as a calculator to do basic maths.\n\n3 + 4\n\n[1] 7\n\n\nor more complicated arithmetic (at least for many on social media‚Ä¶)\n\n8 / 2 * (2 + 2)\n\n[1] 16\n\n\nHere are some of the mathematical operators you can use:\n\n\n\noperator\nfunction\n\n\n\n\n+\naddition\n\n\n-\nsubtraction\n\n\n*\nmultiplication\n\n\n/\ndivision\n\n\n^ or **\nexponentiation/order\n\n\n()\nbrackets\n\n\n%%\nmodulus",
    "crumbs": [
      "Materials",
      "01 - R Basics"
    ]
  },
  {
    "objectID": "docs/01_r-basics.html#objects",
    "href": "docs/01_r-basics.html#objects",
    "title": "Basics of R",
    "section": "Objects",
    "text": "Objects\nPerforming operations and getting the output immediately is handy, but as we start performing more complicated calculations with multiple steps, it is useful to store outputs in memory.\nTo store an object in R, we use the ‚Äòassignment operator‚Äô, &lt;-. On the left side of the arrow is the name we want to give the object, and on the right side is the object we want to store.\n\nmy_sum &lt;- 4 + 2\n\nAs you may notice, there is no output in the console. That‚Äôs a good thing. Take a look in your Environment pane. There is now an object there called my_sum with the value 6.\nTo print the value of the object, we can use the print() function\n\nprint(my_sum)\n\n[1] 6\n\n\nor type the name of the object in the console.\n\nmy_sum\n\n[1] 6\n\n\nWe can now perform further calculations on the object.\n\nmy_sum * 2\n\n[1] 12\n\n\nWe can also overwrite the object by assigning a new value to it.\n\nmy_sum &lt;- 3 * 9\nmy_sum\n\n[1] 27\n\n\nWe can assign multiple values to an object by combining them.\n\nfib &lt;- c(0, 1, 1, 2, 3, 5, 8, 13, 21)\n\nand then the arithmetic operations are applied to each element in the vector.\n\nfib + 2\n\n[1]  2  3  3  4  5  7 10 15 23\n\nfib * 2\n\n[1]  0  2  2  4  6 10 16 26 42\n\n\n\nCommon mistakes\nOne of the most common errors you will encounter is\n\nmy_sums\n#&gt; Error: object 'my_sums' not found\nMy_Sum\n#&gt; Error: object 'My_Sums' not found\n\nR is really good at doing complex calculations. It‚Äôs not very good at reading the minds of humans, or inferring what we mean. Make sure you check for typos!",
    "crumbs": [
      "Materials",
      "01 - R Basics"
    ]
  },
  {
    "objectID": "docs/01_r-basics.html#types-of-r-objects",
    "href": "docs/01_r-basics.html#types-of-r-objects",
    "title": "Basics of R",
    "section": "Types of R objects",
    "text": "Types of R objects\nSo far we have just worked with ‚Äònumeric‚Äô types. my_sum is numeric, but there are two types of numeric: double and integer.\nTo figure out what type my_sum is, we can use another R object called a ‚Äòfunction‚Äô. R has a lot of built-in functions that can perform specific operations. You have already seen print(), which prints objects. We can use class() and typeof() to figure out what is my_sum.\n\nclass(my_sum)\n\n[1] \"numeric\"\n\ntypeof(my_sum)\n\n[1] \"double\"\n\n\nOther types include\n\nTRUE # logical\nFALSE # logical\nNA # logical\n\"string\" # character\n\"also a string\" # character\nNULL # NULL",
    "crumbs": [
      "Materials",
      "01 - R Basics"
    ]
  },
  {
    "objectID": "docs/01_r-basics.html#r-packages",
    "href": "docs/01_r-basics.html#r-packages",
    "title": "Basics of R",
    "section": "R packages",
    "text": "R packages\nThe true power of R is in the packages. The functions and other built-in objects we have been working with so far are part of ‚Äòbase R‚Äô. Stuff that is made available to you when you download R. You can get a lot done with base R. Using packages allows you to extend the functionality of R to pretty much anything you can (and can‚Äôt) imagine.\nPackages are developed and maintained by R users who found something that R couldn‚Äôt do, or was awkward to do, and made a package to fix this. Packages are reviewed by the Comprehensive R Archive Network, or CRAN (Sounds familiar? this is likely where you went to download R).\nAt the time of writing, there are currently 21,205 packages on CRAN. And those are just the official packages that have gone through the submission procedure. There are many more also available on GitHub and other git-hosting platforms. But mostly GitHub (for better or worse).\n\nInstalling packages\nThere are a few different ways to install packages.\nThe quickest way is to do it from the console using the install.packages() function. For example, to install the tidyverse package:\ninstall.packages(\"tidyverse\")\nJust make sure to check your spelling (it‚Äôs also CASE-SENSITIVE).\nThe other option is in RStudio: Tools &gt; Install Packages‚Ä¶\n\n\nLoading packages\nInstalling a package makes it available on your device, but does not load it in R. To do that we use library().\nlibrary(tidyverse) # note no quotation marks\n\n\n\nHere is a more technical overview of package states when you install and load them. Image taken from R Packages (2e)\n\n\nWhen you close RStudio, the packages will be unloaded, and you will have to load them again the next time you open RStudio. This allows R(Studio) to be very lightweight and not accumulate loaded packages resulting in a longer time to open RStudio.",
    "crumbs": [
      "Materials",
      "01 - R Basics"
    ]
  },
  {
    "objectID": "slides/index.html",
    "href": "slides/index.html",
    "title": "Slides",
    "section": "",
    "text": "Basic statistical concepts\n\n\n\n\n\nA quick introduction to basic statistical concepts\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nHello üëã\n\n\n\n\n\nBrief introduction to the materials.\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nRStudio Projects\n\n\n\n\n\nA brief introduction to organising a project with RStudio Projects\n\n\n\n\n\n\n\n\n\nNo matching items"
  },
  {
    "objectID": "slides/content/02_stats-basics.html#why-statistics",
    "href": "slides/content/02_stats-basics.html#why-statistics",
    "title": "Basic statistical concepts",
    "section": "Why statistics?",
    "text": "Why statistics?\n\nKareem Carr via dddrew.com\nBecause they‚Äôre EVERYWHERE",
    "crumbs": [
      "Slides",
      "02 - Stats Basics"
    ]
  },
  {
    "objectID": "slides/content/02_stats-basics.html#section",
    "href": "slides/content/02_stats-basics.html#section",
    "title": "Basic statistical concepts",
    "section": "",
    "text": "We live in a world of randomness\n\n\nStatistics help provide some strucure to the randomness\nand allow us to extract useful information",
    "crumbs": [
      "Slides",
      "02 - Stats Basics"
    ]
  },
  {
    "objectID": "slides/content/02_stats-basics.html#section-1",
    "href": "slides/content/02_stats-basics.html#section-1",
    "title": "Basic statistical concepts",
    "section": "",
    "text": "Data are inherently random\nIf you collect a sample from a population\n\n\nThen collect a second sample from the same population\nThey are very unlikely to be the same observations\n(or measurements)",
    "crumbs": [
      "Slides",
      "02 - Stats Basics"
    ]
  },
  {
    "objectID": "slides/content/02_stats-basics.html#section-2",
    "href": "slides/content/02_stats-basics.html#section-2",
    "title": "Basic statistical concepts",
    "section": "",
    "text": "However some observations will occur more  frequently than others",
    "crumbs": [
      "Slides",
      "02 - Stats Basics"
    ]
  },
  {
    "objectID": "slides/content/02_stats-basics.html#section-3",
    "href": "slides/content/02_stats-basics.html#section-3",
    "title": "Basic statistical concepts",
    "section": "",
    "text": "So we can assume that we will observe an outcome a certain number of times\n\nif an experiment (or analysis) is repeated\n(even if we don‚Äôt actually repeat it)",
    "crumbs": [
      "Slides",
      "02 - Stats Basics"
    ]
  },
  {
    "objectID": "slides/content/02_stats-basics.html#section-4",
    "href": "slides/content/02_stats-basics.html#section-4",
    "title": "Basic statistical concepts",
    "section": "",
    "text": "This allows us to estimate parameters of a population\n\nwithout tediously studying the whole population",
    "crumbs": [
      "Slides",
      "02 - Stats Basics"
    ]
  },
  {
    "objectID": "slides/content/02_stats-basics.html#section-5",
    "href": "slides/content/02_stats-basics.html#section-5",
    "title": "Basic statistical concepts",
    "section": "",
    "text": "and the more experiments we conduct\nor the more data we collect\n\n\nthe closer we get to the true parameters \n(as the number approaches infinity)",
    "crumbs": [
      "Slides",
      "02 - Stats Basics"
    ]
  },
  {
    "objectID": "slides/content/02_stats-basics.html#section-6",
    "href": "slides/content/02_stats-basics.html#section-6",
    "title": "Basic statistical concepts",
    "section": "",
    "text": "This is known as the Frequentist approach\n\n\nAnd is the more common approach in most of science\n(for now‚Ä¶)",
    "crumbs": [
      "Slides",
      "02 - Stats Basics"
    ]
  },
  {
    "objectID": "slides/content/02_stats-basics.html#section-7",
    "href": "slides/content/02_stats-basics.html#section-7",
    "title": "Basic statistical concepts",
    "section": "",
    "text": "A statistic is a single value describing a collection of observations (data from a sample)\n\nSince these observations are not predictable, we can call them a random variable",
    "crumbs": [
      "Slides",
      "02 - Stats Basics"
    ]
  },
  {
    "objectID": "slides/content/02_stats-basics.html#section-8",
    "href": "slides/content/02_stats-basics.html#section-8",
    "title": "Basic statistical concepts",
    "section": "",
    "text": "A statistic is often assigned the generic symbol \\(\\text{T}\\)\nA random variable is assigned \\(\\text{X}\\)\n\nStatistics describing random variables, are themselves random variables (more later)",
    "crumbs": [
      "Slides",
      "02 - Stats Basics"
    ]
  },
  {
    "objectID": "slides/content/02_stats-basics.html#section-9",
    "href": "slides/content/02_stats-basics.html#section-9",
    "title": "Basic statistical concepts",
    "section": "",
    "text": "For example, measurements taken from a sheep‚Äôs astragalus\n\nhttps://doi.org/10.1101/2022.12.24.521859\ncould be considered random variables",
    "crumbs": [
      "Slides",
      "02 - Stats Basics"
    ]
  },
  {
    "objectID": "slides/content/02_stats-basics.html#section-10",
    "href": "slides/content/02_stats-basics.html#section-10",
    "title": "Basic statistical concepts",
    "section": "",
    "text": "Let‚Äôs collect some measurements\n\n\n\n sheep-data.csv",
    "crumbs": [
      "Slides",
      "02 - Stats Basics"
    ]
  },
  {
    "objectID": "slides/content/02_stats-basics.html#section-11",
    "href": "slides/content/02_stats-basics.html#section-11",
    "title": "Basic statistical concepts",
    "section": "",
    "text": "We can describe them in simpler terms using descriptive statistics",
    "crumbs": [
      "Slides",
      "02 - Stats Basics"
    ]
  },
  {
    "objectID": "slides/content/02_stats-basics.html#section-12",
    "href": "slides/content/02_stats-basics.html#section-12",
    "title": "Basic statistical concepts",
    "section": "",
    "text": "We can calculate a central tendency of the data",
    "crumbs": [
      "Slides",
      "02 - Stats Basics"
    ]
  },
  {
    "objectID": "slides/content/02_stats-basics.html#section-13",
    "href": "slides/content/02_stats-basics.html#section-13",
    "title": "Basic statistical concepts",
    "section": "",
    "text": "The arithmetic mean (or ‚Äòaverage‚Äô) of the GLl variable is: 30.34\nIt is calculated as\n\\[\n\\frac{1}{n} \\Sigma_{i=1}^{n} GLl_i\n\\]\n\nWhich is a fancy way of writing: all measurements of GLl added together (sum, or \\(\\Sigma\\))\nthen divided by the number of measurements n, or sample size",
    "crumbs": [
      "Slides",
      "02 - Stats Basics"
    ]
  },
  {
    "objectID": "slides/content/02_stats-basics.html#section-14",
    "href": "slides/content/02_stats-basics.html#section-14",
    "title": "Basic statistical concepts",
    "section": "",
    "text": "Try it in R\n\n\n\nsum(sheep_data$GLl) / length(sheep_data$GLl)\n\n[1] 30.33866\n\nmean(sheep_data$GLl)\n\n[1] 30.33866",
    "crumbs": [
      "Slides",
      "02 - Stats Basics"
    ]
  },
  {
    "objectID": "slides/content/02_stats-basics.html#section-15",
    "href": "slides/content/02_stats-basics.html#section-15",
    "title": "Basic statistical concepts",
    "section": "",
    "text": "This is not very useful information in isolation\n\nGIPHY\nWe need more context",
    "crumbs": [
      "Slides",
      "02 - Stats Basics"
    ]
  },
  {
    "objectID": "slides/content/02_stats-basics.html#section-16",
    "href": "slides/content/02_stats-basics.html#section-16",
    "title": "Basic statistical concepts",
    "section": "",
    "text": "A question we might ask is\n\n\nhow much do the data vary around the mean?",
    "crumbs": [
      "Slides",
      "02 - Stats Basics"
    ]
  },
  {
    "objectID": "slides/content/02_stats-basics.html#section-17",
    "href": "slides/content/02_stats-basics.html#section-17",
    "title": "Basic statistical concepts",
    "section": "",
    "text": "We can calculate the difference between\nthe mean of our sample (\\(\\bar{x}\\)) and each observation (\\(x_i\\))\nand sum\n\\[\n\\sum(x_i - \\bar{x})\n\\]\n\n\nBut that would essentially give us zero\nbecause there is roughly an equal number of measurements below and above the mean\n(hence it‚Äôs a measure of central tendency‚Ä¶)",
    "crumbs": [
      "Slides",
      "02 - Stats Basics"
    ]
  },
  {
    "objectID": "slides/content/02_stats-basics.html#sum-of-squares",
    "href": "slides/content/02_stats-basics.html#sum-of-squares",
    "title": "Basic statistical concepts",
    "section": "",
    "text": "so we square the result to remove negative values\n\\[\n\\sum_{i=1}^{n}(x_i - \\bar{x})^2\n\\]\n\n\nwhich gives us the sum of squared differences",
    "crumbs": [
      "Slides",
      "02 - Stats Basics"
    ]
  },
  {
    "objectID": "slides/content/02_stats-basics.html#sum-of-squares-caveat",
    "href": "slides/content/02_stats-basics.html#sum-of-squares-caveat",
    "title": "Basic statistical concepts",
    "section": "",
    "text": "But\nlarger samples\nwill have\nlarger differences\nmaking it difficult to compare different-sized samples",
    "crumbs": [
      "Slides",
      "02 - Stats Basics"
    ]
  },
  {
    "objectID": "slides/content/02_stats-basics.html#variance",
    "href": "slides/content/02_stats-basics.html#variance",
    "title": "Basic statistical concepts",
    "section": "",
    "text": "So we divide by sample size, n (minus 1), to standardise\n\\[\ns^2 = \\frac{\\sum_{i=1}^{n}(x_i - \\bar{x})^2}{n - 1}\n\\]\n\nand obtain the variance  \\(s^2\\)",
    "crumbs": [
      "Slides",
      "02 - Stats Basics"
    ]
  },
  {
    "objectID": "slides/content/02_stats-basics.html#section-18",
    "href": "slides/content/02_stats-basics.html#section-18",
    "title": "Basic statistical concepts",
    "section": "",
    "text": "Try it in R\n\n\n\nsum((sheep_data$GLl - mean(sheep_data$GLl)) ** 2) / (length(sheep_data$GLl) - 1)\n\n[1] 2.24968\n\nvar(sheep_data$GLl)\n\n[1] 2.24968",
    "crumbs": [
      "Slides",
      "02 - Stats Basics"
    ]
  },
  {
    "objectID": "slides/content/02_stats-basics.html#standard-deviation",
    "href": "slides/content/02_stats-basics.html#standard-deviation",
    "title": "Basic statistical concepts",
    "section": "",
    "text": "Because we‚Äôre squaring the differences, the numbers can quickly get unruly\nSo we can take the square root of the variance\n\\[\ns = \\sqrt{s^2} = \\sqrt{\\frac{\\sum_{i=1}^{n}(x_i - \\bar{x})^2}{n - 1}}\n\\]\n\nto get the standard deviation  \\(s\\)",
    "crumbs": [
      "Slides",
      "02 - Stats Basics"
    ]
  },
  {
    "objectID": "slides/content/02_stats-basics.html#section-19",
    "href": "slides/content/02_stats-basics.html#section-19",
    "title": "Basic statistical concepts",
    "section": "",
    "text": "Try it in R\n\n\n\nsqrt(var(sheep_data$GLl))\n\n[1] 1.499893\n\nvar(sheep_data$GLl) ** (1/2)\n\n[1] 1.499893\n\nsd(sheep_data$GLl)\n\n[1] 1.499893",
    "crumbs": [
      "Slides",
      "02 - Stats Basics"
    ]
  },
  {
    "objectID": "slides/content/02_stats-basics.html#section-20",
    "href": "slides/content/02_stats-basics.html#section-20",
    "title": "Basic statistical concepts",
    "section": "",
    "text": "Combined with the mean\nstandard deviation can say more about our data\n\n\nBut for the whole sample this is not very informative",
    "crumbs": [
      "Slides",
      "02 - Stats Basics"
    ]
  },
  {
    "objectID": "slides/content/02_stats-basics.html#section-21",
    "href": "slides/content/02_stats-basics.html#section-21",
    "title": "Basic statistical concepts",
    "section": "",
    "text": "We could calculate summary statistics across multiple groups\n\n\n\n  \n\n\n\nBut how do we know if the groups differ (or not) in a meaningful way?",
    "crumbs": [
      "Slides",
      "02 - Stats Basics"
    ]
  },
  {
    "objectID": "slides/content/02_stats-basics.html#section-22",
    "href": "slides/content/02_stats-basics.html#section-22",
    "title": "Basic statistical concepts",
    "section": "",
    "text": "We could run some statistical test\nbut which one?\n\n\n\n\n\n\n\nGIPHY",
    "crumbs": [
      "Slides",
      "02 - Stats Basics"
    ]
  },
  {
    "objectID": "slides/content/02_stats-basics.html#common-question-2",
    "href": "slides/content/02_stats-basics.html#common-question-2",
    "title": "Basic statistical concepts",
    "section": "",
    "text": "The correct answer: It depends‚Ä¶",
    "crumbs": [
      "Slides",
      "02 - Stats Basics"
    ]
  },
  {
    "objectID": "slides/content/02_stats-basics.html#section-23",
    "href": "slides/content/02_stats-basics.html#section-23",
    "title": "Basic statistical concepts",
    "section": "",
    "text": "Primarily it depends on what do your data look like?\n\nR for Data Science",
    "crumbs": [
      "Slides",
      "02 - Stats Basics"
    ]
  },
  {
    "objectID": "slides/content/02_stats-basics.html#section-24",
    "href": "slides/content/02_stats-basics.html#section-24",
    "title": "Basic statistical concepts",
    "section": "",
    "text": "Descriptive statistics only get you so far‚Ä¶\n\nz3tt/TidyTuesday",
    "crumbs": [
      "Slides",
      "02 - Stats Basics"
    ]
  },
  {
    "objectID": "slides/content/02_stats-basics.html#section-25",
    "href": "slides/content/02_stats-basics.html#section-25",
    "title": "Basic statistical concepts",
    "section": "",
    "text": "We need to explore the data",
    "crumbs": [
      "Slides",
      "02 - Stats Basics"
    ]
  }
]